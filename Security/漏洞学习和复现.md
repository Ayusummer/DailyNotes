# 漏洞学习和复现

> 1.漏洞简介
>
> 2.漏洞利用原理
>
> 3.漏洞利用过程
>
> 4.防护建议

## XSS漏洞利用学习和复现

[网络安全必学知识点之XSS漏洞 (baidu.com)](https://baijiahao.baidu.com/s?id=1711691365751381912&wfr=spider&for=pc)

[【XSS漏洞-01】XSS漏洞简介、危害与分类及验证_像风一样9的博客-CSDN博客_xss漏洞](https://blog.csdn.net/m0_64378913/article/details/124654153)

### 1.XSS漏洞简介

#### XSS(跨站脚本——Cross-Site Scripting)

XSS全称跨站脚本(Cross Site Scripting)，为避免与层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故缩写为XSS。这是一种将任意 Javascript 代码插入到其他Web用户页面里执行以达到攻击目的的漏洞。攻击者利用浏览器的动态展示数据功能，在HTML页面里嵌入恶意代码。当用户浏览该页时，这些潜入在HTML中的恶意代码会被执行，用户浏览器被攻击者控制，从而达到攻击者的特殊目的，如 cookie窃取等。

XSS的本质是一种针对网站应用程序的安全漏洞攻击技术，是代码注入的一种。

**特点**：XSS主要基于**JavaScript**完成恶意的攻击行为，由于JS可以非常灵活地操作html、css和浏览器，使得跨站脚本攻击的“想象”空间特别大。

**攻击对象**：被攻击者的浏览器。用户最简单的动作就是使用浏览器上网，并且浏览器中有javascript解释器，可以解析javascript，然后浏览器不会判断代码是否恶意，也就是说xss的对象是用户的浏览器。

**一般的攻击过程**：

- 攻击者将恶意代码注入到服务器中（如论坛、留言板、邮件等）；
- 用户在没有防备的情况下访问了被注入了恶意代码的服务器；
- 服务器将含有恶意代码的网页响应给客户端；
- 在客户端浏览器中触发JS恶意代码。

### 2.产生原因、漏洞原理

形成XSS漏洞的主要原因是**程序对输入和输出的控制不够严格，导致“精心构造”的脚本输入后，在输到前端时被浏览器当作有效代码解析执行从而产生危害。**

对于存在XSS漏洞的服务器，攻击者可以直接登陆该网站，尝试XSS漏洞利用（主要使用存储型XSS漏洞利用，将脚本写入服务器，其他用户浏览时会被攻击）

攻击者也可以构造链接，将脚本写入链接中，受害者点击链接后，会访问服务器，服务器返回HTML文件后会和URL中的脚本一起被受害者浏览器渲染解析，从而实现攻击

### 3.危害

攻击者通过Web应用程序发送恶意代码，一般以浏览器脚本的形式发送给不同的终端用户。当一个Web程序的用户输入点没有进行校验和编码，将很容易的导致XSS。

1、网络钓鱼，包括获取各类用户账号
2、窃取用户cookies资料，从而获取用户隐私信息，或利用用户身份进一步对网站执行操作；
3、劫持用户（浏览器）会话，从而执行任意操作，例如非法转账、强制发表日志、电子邮件等
4、强制弹出广告页面、刷流量等
5、网页挂马
6、进行恶意操作，如任意篡改页面信息、删除文章等
7、进行大量的客户端攻击，如ddos等
8、获取客户端信息，如用户的浏览历史、真实Ip、开放端口等
9、控制受害者机器向其他网站发起攻击；
10、结合其他漏洞，如csrf，实施进步危害；
11、提升用户权限，包括进一步渗透网站
12、传播跨站脚本蠕虫等

### 4.防御手段

在XSS漏洞的防范上，一般会采用“对输入进行过滤”和“输出进行转义”的方式进行处理: 

> 输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入; 

> 输出转义：根据输出点的位置对输出到前端的内容进行适当转义;

### 5.XSS常出现地

1、数据交互的地方

> get、post、cookies、headers
>
> 反馈与浏览
>
> 富文本编辑器
>
> 各类标签插入和自定义

2、数据输出的地方

> 用户资料
>
> 关键词、标签、说明
>
> 文件上传

### 6.XSS分类

#### 反射性XSS：

也叫非持久型XSS、参数型夸张脚本，这种共计方式往往具有一次性，只在用户单击时触发。跨站代码一般存在在链接中，当受害者请求这样的链接时，跨站代码经过服务端反射回来，这类跨站的代码通常不存储在服务端。反射型XSS的JS代码在web应用的**参数**（变量）中，如搜索框的反射型XSS。

常见注入点:
网站的搜索栏、用户登录入口、输入表单等地方，常用来窃取客户端cookies或钓鱼欺骗。

漏洞产生原因：

一般网站只是简单地将用户输入的数据直接或未经过完善的安全过滤就在浏览器中进行输岀，导致输岀的欻据中存在可被浏览器执行的代码数据

攻击方式：
攻击者通过电子邮件等方式将包含XSS代码的恶意链接发送给目标用户。当目标用户访问该链接时，服务器接受该目标用户的请求并进行处理，然后服务器把带有XSS的代码发送给目标用户的浏览器，浏览器解析这段带有XSS代码的恶意脚本后，就会触发XSS漏洞。

由于此种类型的跨站代码存在于URL中，所以黑客通常需要通过诱骗或加密变形等方式将存在恶意代码的链接发给用户，只有用户点击以后才能使得攻击成功实施。

反射型XSS攻击流程：

1.攻击者寻找具有漏洞的网站
2.攻击者给用户发了一个带有恶意字符串的链接
3.用户点击了该链接
4.服务器返回HTML文档，此时该文档已经包含了那个恶意字符串
5.客户端执行了植入的恶意脚本，XSS攻击就发生

#### 存储型XSS

存储型XSS（ Stored XSS Attacks），也叫持久型XSS漏洞，比反射性XSS更具有威胁性，攻击脚本被永久存储在目标服务器的数据库或文件中，这是利用起来最方便的跨站类型，跨站代码存储于服务端（比如数据库中）。

常见的注入点：

论坛、博客、留言板、网站的留言、评论、日志等交互处。

漏洞原因：

造成漏洞原因一般是由于Web应用程序对用户输入数据的不严格，导致Web应用程序将黑客输入的恶意跨站攻击数据信息保存在服务端的数据库或其他文件形式中。

攻击方式：

攻击者在发帖或留言的过程中，将恶意脚本连同正常信息一起注入到发布内容中。随着发布内容被服务器存储下来，恶意脚本也将永久的存放到服务器的后端存储器中。当其他用户浏览这个被注入了恶意脚本的帖子时，恶意脚本就会在用户的浏览器中得到执行。

存储型XSS攻击的流程：

1.用户提交了一条包含XSS代码的留言到数据库
2.当目标用户查询留言时，那些留言的内容会从服务器解析之后加载出来
3.浏览器发现有XSS代码，就当做正常的HTML和JS解析执行

#### DOM型XSS

##### HTML DOM

[HTML DOM 教程 | 菜鸟教程 (runoob.com)](https://www.runoob.com/htmldom/htmldom-tutorial.html)

DOM是文档对象模型（Document Object Model），DOM是HTML文档的对象表示，同时也是外部内容(JavaScript)与HTML元素之间的接口，解析树的根节点是  "Document"对象。使用DOM能够使程序和脚本能够动态访问和更新文档的内容、结构和样式。HTML DOM 定义了访问和操作 HTML 文档的标准方法。DOM 以树结构表达 HTML 文档。

HTML 的标签都是节点，而这些节点组成了 DOM 的整体结构一一节点树。通过HTML DOM，树中的所有节点均可通过JavaScript进行访问 。 所有HTML元素（节点）均可被修改，也可以创建或删除节点 。

![image-20220801112140481](漏洞学习和复现.assets/image-20220801112140481.png)





DOM型XSS是基于DOM文档对象的一种漏洞，并且DOM型XSS是基于JS上的，并不需要与服务器进行交互。其通过修改页面DOM节点数据信息而形成的ⅩSS跨站脚本攻击。不同于反射型XSS和存储型XSS，基于DOM的XSS跨站脚本攻击往往需要针对具体的 Javascript DOM代码进行分析，并根据实际情况进行XSS跨站脚本攻击的利用。DOM型XSS是一种基于DOM的跨站脚本，这是客户端脚本本身解析不正确导致的安全问题。攻击的payload由于修改受害者浏览器页面的**DOM树**而执行的。其特殊的地方就是payload在浏览器本地修改DOM树而执行，并不会传到服务器上，这也就使得DOM型XSS比较难以检测。

网页的生成及修改：

- 在网站页面中有许多元素，当页面到达浏览器时，浏览器会为页面创建一个顶级的Document object文档对象，接着生成各个子文档对象，每个页面元素对应一个文档对象，每个文档对象包含属性、方法和事件 。
- 可以通过JS脚本对文档对象进行编辑，从而修改页面的元素 。 也就是说，客户端的脚本程序可以通过DOM动态修改页面内容，从客户端获取DOM中的数据并在本地执行。由于DOM是在客户端修改节点的，所以基于DOM型的xss漏洞不需要与服务器端交互，它只发生在客户端处理数据的阶段。

常见注入点：

通过JS脚本对对文档对象进行编辑，从而修改页面的元素。也就是说，客户端的脚本程序可以动态修改页面的内容，从客户端获取DOM中的数据并在本地执行。由于DOM是在客户端修改节点的，所以基于DOM型的XSS漏洞不需要与服务器端交互，它只发生在客户端处理数据的阶段。

攻击方式：

用户请求一个经过专门设计的URL，它由攻击者提供，而且其中包含XSS代码。服务器的响应不会以任何形式包含攻击者的脚本，当用户的浏览器处理这个响应时，DOM对象就会处理XSS代码，导致存在XSS漏洞。

DOM型XSS流程：

1.攻击者寻找具有漏洞的网站
2.攻击者给用户发了一个带有恶意字符串的链接
3.用户点击了该链接
4.服务器返回HTML文档，但是该文档此时不包含那个恶意字符串
5.客户端执行了该HTML文档里的脚本，然后把恶意脚本植入了页面
6.客服端执行了植入的恶意脚本，XSS攻击就发生了

其他类型的XSS：
MXSS(突变XSS--MXSS, Mutation based Cross-Site-Scripting)，不论是服务器端或客户端的ⅩSS过滤器，都认定过滤后的HTM源代码应该与浏览器所渲染后的HTML代码保持一致，至少不会出现很大的出入，然而，如果用户所提供的富文本内容通过 Javascript 代码进属性后，一些意外的变化会使得这个认定不再成立：一串看似没有任何危害的HTML代码，将逃过XSS过滤器的检测，最终进入某个DOM节点中，浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。 随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。这种由于HTML内容进后发生意外变化（ mutation，突变，来自遗传学的一个单词，基因突变，gene mutation），而最终导致MXSS的攻击流程。

通常通过innerHTML函数进行html代码过滤

![image-20220801110101768](漏洞学习和复现.assets/image-20220801110101768.png)

什么是HTML过滤器？为什么需要HTML过滤器？

许多web应用程序，以编辑器的形式，允许用户使用一些特殊的文本格式（例如，粗体，斜体等等）。这个功能在博客，邮件当中使用甚广。这里出现的主要安全问题就是有些不法用户可能输入一些恶意HTML/JavaScript从而引入XSS。 因此，这类允许用户进行个性化输入的应用程序的创建者就面临一个很头疼的问题如何确保用户的输入的HTML是安全的，从而不会引起不必要的XSS。 这就是为什么需要HTML过滤器的原因。HTML过滤器的主要目的是揪出不可信的输入，对其进行过滤，并生成安全的HTML，过滤所有具有危险标签的HTML。

### 7.漏洞验证

#### 7.1 漏洞验证相关概念

- POC：全称 ’ Proof of Concept '，中文 ’ 概念验证 ’ ，常指一段漏洞验证的代码。
- EXP：全称 ’ Exploit '，中文 ’ 利用 '，指利用系统漏洞进行攻击的工具，即从漏洞检测验证到利用的工具。
- Payload：中文 ’ 有效载荷 '，指成功exploit之后，真正在目标系统执行的代码或指令。
- Shellcode：简单翻译 ’ shell代码 '，利用漏洞时所执行的代码，是Payload的一种。Shellcode也有很多种，包括正向的，反向的，甚至meterpreter。

##### Payload攻击载荷

> payload称为攻击载荷，主要用于建立目标机与攻击机之间的稳定连接，并返回一个shell，也可以进行程序注入等。
>
> 3种类型
>
> （1）singles（独立载荷）
>
> 独立载荷，可直接植入目标系统并执行相应的程序，如：shell_bind_tcp。
>
> （2）stagers（传输器载荷）
>
> 传输器载荷，用于目标机与攻击机之间建立稳定的网络连接，与stages（传输体载荷）配合攻击。通常该种载荷体积都非常小，可以在漏洞利用后，方便进行注入，这类载荷功能都非常相似，大致分为bind型和reverse型。
>
> bind型：需要攻击机主动连接目标端口。
>
> reverse型：目标机反向连接攻击机，需要提前设定好连接攻击机的ip地址和端口号。
>
> （3）stages（传输体）
>
> 传输体载荷，在stagers建立好稳定的连接后，攻击机将stages传输给目标机，由stagers进行相应处理，将控制权转交给stages。如得到目标机的shell或者meterpreter控制程序运行。这样攻击机可以在本端输入相应命令控制目标机。

#### 7.2 漏洞验证相关概念之间的区别

（1）POC与EXP对比
POC是用来验证漏洞存在的，EXP是用来完整利用漏洞(包括从验证到利用全过程)的，两者通常不是一类，或者说，PoC通常是无害的，Exp通常是有害的，有了POC，才有EXP。
（2）Payload与Shellcode
Payload有很多种，它可以是Shellcode，也可以直接是一段系统命令。
（3）Payload与EXP
同一个Payload可以用于多个漏洞，但每个漏洞都有其自己的EXP，也就是说不存在通用的EXP。
（4）Payload模块
在Metasploit Framework 6大模块中有一个Payload模块，在该模块下有Single、Stager、Stages这三种类型，Single是一个all-in-one的Payload，不依赖其他的文件，所以它的体积会比较大，Stager主要用于当目标计算机的内存有限时，可以先传输一个较小的Stager用于建立连接，Stages指利用Stager建立的连接下载后续的Payload。Stager和Stages都有多种类型，适用于不同场景。

### 8.XSS漏洞验证复现

登陆容器后进入DVWA页面，需要创建数据库

问题

点击Create/Reset Database按钮后提示：
Could not connect to the database service.Please check the config file.
Database Error #1045:Access denied for user’dvwa’@‘locahost’(using password:YES).

![在这里插入图片描述](漏洞学习和复现.assets/7543bafbf2d345d8a6b56634c351d33f.png)

解决方法：按下图修改config.inc.php文件

![在这里插入图片描述](漏洞学习和复现.assets/9c1a097b4bc7425e9fa1b85352bb3103.png)



无法进入mysql:

[ERROR 1045 (28000): Access denied for user ‘root‘@‘localhost‘ (using password: NO)解决办法_BugMiaowu2021的博客-CSDN博客](https://blog.csdn.net/m0_46278037/article/details/113923726#:~:text=重置密码解决 MySQL for Linux错误 ERROR 1045 (28000)%3A Access,d]文本段：%2F mysql d (在vim编辑状态下直接输入该命令可搜索文本内容) 在 [ mysql d]后面任意一行添加)

应该使用已知的用户名和密码登陆

[ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES/NO) 解决方案1.停止mysql - 腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1188636)

MySQL安装时默认的用户是root，这里的root是指[数据库](https://cloud.tencent.com/solution/database?from=10680)的用户，root密码一般在初始化MySQL时存放在你的日志文件中，日志文件的存放路径可以通过my.cnf文件进行自定义。

mysql -u root -p  （root用户密码设置过是root）



DVWA有安全级别：（默认是high）

#### 8.1反射型XSS漏洞复现

反射型XSS漏洞常存在于参数中。

[二、详解 DVWA_Reflected反射型XSS_在下小黄的博客-CSDN博客](https://blog.csdn.net/weixin_44519789/article/details/124919065)

![image-20220801160344719](漏洞学习和复现.assets/image-20220801160344719.png)

![image-20220801160450725](漏洞学习和复现.assets/image-20220801160450725.png)相同内容只渲染一次(同一个<script>alert('xss')</script>)

可能浏览器会在输入端识别，直接拦截威胁，需要更换浏览器渗透，写的文件作为渗透payload可能会被防火墙识别隔离，需要关闭防火墙。

由于服务器的源代码没有对表单的输入进行过滤，用户输入数据被直接被服务器将用户输入插入到HTML文件的标签中，因此如果存在恶意参数（表单提交内容是恶意脚本），浏览器就会解析执行这个脚本，从而实现了XSS的反射型漏洞利用。

![image-20220826105951694](http://cdn.ayusummer233.top/img/image-20220826105951694.png)

![image-20220826110007217](http://cdn.ayusummer233.top/img/image-20220826110007217.png)

#### 8.2存储型XSS漏洞复现

查看网页html代码：

发现输入文本的地方是textare标签指明的文本编辑器

测试发现输入文本内容后后端会将输入的内容放在<div>标签里，测试将脚本<script>alert(123)</script>输入textarea标签内提交查看是否被执行

![image-20220823164213673](http://cdn.ayusummer233.top/img/image-20220823164213673.png)

发现服务器没有对用户的输入进行过滤，会直接将用户输入存储并且显示在HTML网页中返回给前端，前端解析渲染这个HTML文件时，由于文件中存在用户输入的恶意脚本，会解析执行这个脚本，所以所有查看这个评论的客户端都会被攻击。

![image-20220826105826530](http://cdn.ayusummer233.top/img/image-20220826105826530.png)

![image-20220826105815157](http://cdn.ayusummer233.top/img/image-20220826105815157.png)

#### 8.3DOM型XSS漏洞复现

DVWA中的服务器在XSS(DOM)服务中将用户选项加在URL后面返回给前端，以此来传递参数，前端接受到参数后将URL中的value设为option的value，尝试在url的值后面加入脚本，查看前端页面html代码

![image-20220823164037341](http://cdn.ayusummer233.top/img/image-20220823164037341.png)



此处在URL中加入docunment脚本尝试执行

```
<script>
var a = document.URL; //将当前界面的URL赋值给变量a
a = unescape(a); //URL中有些代码可能经过URL编码，此处将URL进行解码
document.write(a.substring(a.indexOf('#')+1,a.length));//a.indexof:字符串首次出现的位置，+1:跳过#锚为取#之后的字符    写入html元素
</script>
或者
<script>var w = document.getElementsByTagName("BODY")[0];w.style.backgroundColor = "red";</script>
```

![image-20220823185531596](http://cdn.ayusummer233.top/img/image-20220823185531596.png)



查看源码：

![image-20220826101810776](http://cdn.ayusummer233.top/img/image-20220826101810776.png)

前端通过GET命令访问后端时，会将参数写在URL后面，后端回应的URL会 使用请求的URL，脚本中会将URL中的参数写入到HTML元素中，如果此链接中存在恶意脚本，脚本就会被插入到HTML文件中，从而被浏览器解析执行。此时URL中携带有修改DOM元素的脚本，前端就会操作DOM元素。

## 中间设备对于攻击报文的检测

WAF检测到XSS攻击报文

![image-20220826142248918](http://cdn.ayusummer233.top/img/image-20220826142248918.png)

IPS也检测到了XSS漏洞攻击：

![image-20220826142345255](http://cdn.ayusummer233.top/img/image-20220826142345255.png)

智源检测到服务器被攻击：

![image-20220826142443724](http://cdn.ayusummer233.top/img/image-20220826142443724.png)

智源的攻击分析：

![image-20220826142534871](http://cdn.ayusummer233.top/img/image-20220826142534871.png)

## 常用的XSS攻击脚本：(如果使用中文符号会无法执行)

### 畸形的A标签

跳过HREF标签找到XSS的重点......由DavidCross提交~已在Chrome上验证：

```
<a onmouseover="alert(document.cookie)">xxs link</a>
```

此外Chrome经常帮你补全确实的引号......如果在这方面遇到问题就直接省略引号，Chrome会帮你补全在URL或脚本中缺少的引号。

```
<a onmouseover=alert(document.cookie)>xxs link</a>
```

### 畸形的IMG标签

最初由Begeek发现（短小精湛适用于所有浏览器），这个XSS攻击向量使用了不严格的渲染引擎来构造含有IMG标签并被引号包含的XSS攻击向量。我猜测这种解析原来是为了兼容不规范的编码。这会让它更加难以正确的解析HTML标签：

```
<IMG """"><SCRIPT>alert("XSS")</SCRIPT>">
```

### 事件处理程序

在XSS攻击中可使用以下事件（在完稿的时候这是网上最全的列表了）。

```
FSCommand() (攻击者当需要在嵌入的Flash对象中执行时可以使用此事件)
onAbort() (当用户中止加载图片时)
onActivate() (当对象激活时)
onAfterPrint() (用户打印或进行打印预览后触发)
onAfterUpdate() (从数据源对象更新数据后由数据对象触发)
onBeforeActivate() (在对象设置为激活元素前触发)
onBeforeCopy() (攻击者在选中部分拷贝到剪贴板前执行攻击代码-攻击者可以通过执行execCommand("Copy")函数触发)
onBeforeCut() (攻击者在选中部分剪切到剪贴板前执行攻击代码)
onBeforeDeactivate() (在当前对象的激活元素变化前触发)
onBeforeEditFocus() (在一个包含可编辑元素的对象进入激活状态时或一个可编辑的对象被选中时触发)
onBeforePaste() (在用户被诱导进行粘贴前或使用execCommand("Paste")函数触发)
onBeforePrint() (用户需要被诱导进行打印或攻击者可以使用print()或execCommand("Print")函数).
onBeforeUnload() (用户需要被诱导关闭浏览器-除非从父窗口执行，否则攻击者不能关闭当前窗口)
onBeforeUpdate() (从数据源对象更新数据前由数据对象触发)
onBegin() (当元素周期开始时由onbegin 事件立即触发)
onBlur() (另一个窗口弹出当前窗口失去焦点时触发)
onBounce() (当marquee对象的behavior属性设置为“alternate”且字幕的滚动内容到达窗口一边时触发)
onCellChange() (当数据提供者的数据变化时触发)
onChange() (select，text, 或TEXTAREA字段失去焦点并且值发生变化时触发)
onClick() (表单中点击触发)
onContextMenu() (用户需要在攻击区域点击右键)
onControlSelect() (当用户在一个对象上创建控件选中区时触发)
onCopy() (用户需要复制一些东西或使用execCommand("Copy")命令时触发)
onCut() (用户需要剪切一些东西或使用execCommand("Cut")命令时触发)
onDataAvailable() (用户需要修改元素中的数据，或者由攻击者提供的类似功能)
onDataSetChanged() (当数据源对象变更导致数据集发生变更时触发)
onDataSetComplete() (数据源对象中所有数据可用时触发)
onDblClick() (用户双击一个表单元素或链接)
onDeactivate() (在激活元素从当前对象转换到父文档中的另一个对象时触发)
onDrag() (在元素正在拖动时触发)
onDragEnd() (当用户完成元素的拖动时触发)
onDragLeave() (用户在拖动元素离开放置目标时触发)
onDragEnter() (用户将对象拖拽到合法拖曳目标)
onDragOver() (用户将对象拖拽划过合法拖曳目标)
onDragDrop() (用户将一个对象（例如文件）拖拽到浏览器窗口)
onDragStart() (当用户开始拖动元素时触发)
onDrop() (当拖动元素放置在目标区域时触发)
onEnded() (在视频/音频（audio/video）播放结束时触发)
onError() (在加载文档或图像时发生错误)
onErrorUpdate() (当从数据源对象更新相关数据遇到错误时在数据绑定对象上触发)
onFilterChange() (当滤镜完成状态变更时触发)
onFinish() (当marquee完成滚动时攻击者可以执行攻击)
onFocus() (当窗口获得焦点时攻击者可以执行攻击代码)
onFocusIn() (当元素将要被设置为焦点之前触发)
onFocusOut() (攻击者可以在窗口失去焦点时触发攻击代码)
onHashChange() (当锚部分发生变化时触发攻击代码)
onHelp() (攻击者可以在用户在当前窗体激活时按下F1触发攻击代码)
onInput() (在 <input> 或 <textarea> 元素的值发生改变时触发)
onKeyDown() (用户按下一个键的时候触发)
onKeyPress() (在键盘按键被按下并释放一个键时触发)
onKeyUp() (用户释放一个键时触发)
onLayoutComplete() (用户进行完打印或打印预览时触发)
onLoad() (攻击者在窗口加载后触发攻击代码)
onLoseCapture() (可以由releaseCapture()方法触发)
onMediaComplete() (当一个流媒体文件使用时，这个事件可以在文件播放前触发)
onMediaError() (当用户在浏览器中打开一个包含媒体文件的页面，出现问题时触发事件)
onMessage() (当页面收到一个信息时触发事件)
onMouseDown() (攻击者需要让用户点击一个图片触发事件)
onMouseEnter() (光标移动到一个对象或区域时触发)
onMouseLeave() (攻击者需要让用户光标移动到一个图像或表格然后移开来触发事件)
onMouseMove() (攻击者需要让用户将光标移到一个图片或表格)
onMouseOut() (攻击者需要让用户光标移动到一个图像或表格然后移开来触发事件)
onMouseOver() (光标移动到一个对象或区域)
onMouseUp() (攻击者需要让用户点击一个图片)
onMouseWheel() (攻击者需要让用户使用他们的鼠标滚轮)
onMove() (用户或攻击者移动页面时触发)
onMoveEnd() (用户或攻击者移动页面结束时触发)
onMoveStart() (用户或攻击者开始移动页面时触发)
onOffline() (当浏览器从在线模式切换到离线模式时触发)
onOnline() (当浏览器从离线模式切换到在线模式时触发)
onOutOfSync() (当元素与当前时间线失去同步时触发)
onPaste() (用户进行粘贴时或攻击者可以使用execCommand("Paste")函数时触发)
onPause() (在视频或音频暂停时触发)
onPopState() (在窗口的浏览历史（history 对象）发生改变时触发)
onProgress() (攻击者可以在一个FLASH加载时触发事件)
onPropertyChange() (用户或攻击者需要改变元素属性时触发)
onReadyStateChange() (每次 readyState 属性变化时被自动调用)
onRedo() (用户返回上一页面时触发)
onRepeat() (事件在播放完重复播放时触发)
onReset() (用户或攻击者重置表单时触发)
onResize() (用户改变窗口大小时，攻击者可以自动以这种方法触发:<SCRIPT>self.resizeTo(500,400);</SCRIPT>)
onResizeEnd() (用户完成改变窗体大小时触发)
onResizeStart() (用户开始改变窗体大小时触发)
onResume() (当元素继续播放时触发)
onReverse() (当元素回放时触发)
onRowsEnter() (用户或攻击者需要改变数据源中的一行)
onRowExit() (用户或攻击者改变数据源中的一行后退出时触发)
onRowDelete() (用户或攻击者需要删除数据源中的一行)
onRowInserted() (user or attacker would needto insert a row in a data source)
onScroll() (用户需要滚动或攻击者使用scrollBy()函数)
onSeek() (当用户在元素上执行查找操作时触发)
onSelect() (用户需要选择一些文本-攻击者可以以此方式触发: window.document.execCommand("SelectAll");)
onSelectionChange() (当用户选择文本变化时触发-攻击者可以以此方式触发: window.document.execCommand("SelectAll");)
onSelectStart() (当用户开始选择文本时触发-攻击者可以以此方式触发: window.document.execCommand("SelectAll");)
onStart() (在marquee 对象开始循环时触发)
onStop() (当用户按下停止按钮或离开页面时触发)
onStorage() (当Web Storage更新时触发)
onSyncRestored() (当元素与它的时间线恢复同步时触发)
onSubmit() (需要用户或攻击者提交表单)
onTimeError() (用户或攻击者设置时间属性出现错误时触发)
onTrackChange() (用户或攻击者改变播放列表内歌曲时触发)
onUndo() (用户返回上一浏览记录页面时触发)
onUnload() (用户点击任意链接或按下后退按钮或攻击者强制进行点击时触发)
onURLFlip() (当一个高级流媒体格式（ASF）文件，由一个HTML+TIME（基于时间交互的多媒体扩展）媒体标签播放时，可触发在ASF文件中内嵌的攻击脚本)
seekSegmentTime() (这是一个方法可以定位元素某个时间段内中的特定的点，并可以从该点播放。这个段落包含了一个重复的时间线，并包括使用AUTOREVERSE属性进行反向播放。)
```

## 文件上传漏洞

![image-20220803164035274](漏洞学习和复现.assets/image-20220803164035274.png)

上传一张图片后，浏览器捕获报文（包括请求和响应报文）

一次提交后可能会有多个报文收到，设计web页面的异步加载（其他报文可能是后端陆续发送的，前端浏览器会有回调函数，根据response执行）

可以修改捕获的报文，重写报文后发送

![image-20220803164454561](漏洞学习和复现.assets/image-20220803164454561.png)

可以重新上传别的文件后（因为此种安全级别下的前端负责检查文件类型，检查结果通过变量传给后端，可以看源php看出来）

修改Content-Type为image/jpeg，然后上传即可绕过文件检查，或者修改文件名，在Content-Type下面输入具体文件内容也可以

后端收到变量符合条件后此级别直接保存文件，前端输入对应文件的URL即可访问文件，如果文件可以执行对应命令并显示，则实现了渗透

前端输入URL后加上？name=phpinfo()  即可在后端执行此命令

<?php

 echo($_GET[name])

?>

## ARP欺骗

> ARP地址解析协议，为网络层协议，用于将MAC地址与IP地址建立映射关系。
>
> 当发送端知道接收端的IP地址，但是不知道其对应的MAC地址，这个时候就需要请求其接收端MAC地址，于是发送端会广播的发送ARP Request包，所有收到请求数据包的设备都会进行处理，若非目标设备收到请求包后会直接进行丢弃操作，而目标主机不仅会记录发送端的IP地址和MAC地址放入自己的ARP缓存中，并同时进行响应，发送ARP Reply包给发送段，发送端接收后会记录目标端的IP地址与MAC地址，双方建立通信。

### ARP攻击

ARP攻击主要目的就是使网络无法正常通信，就是通过伪造IP地址和MAC地址实现ARP欺骗。

![img](http://cdn.ayusummer233.top/img/f50004a28ed424543e4dbbd6867650f1.png)

（1） 当PC1在请求PC2的MAC地址时，交换机ARP缓存无PC2的对应条目则会广播发送Arp Request请求包进行请求询问；

（2） 如果我是PC3想攻击PC1，在收到PC1的Arp请求包的时候，我接收这个请求，同时回应一个虚假的回应包，告诉PC1我就是PC2。

（3） 然后PC1就会收到2条说自己是PC1的回应包，但是PC1并不知道到底哪个是真的，所以PC1会做出判断，并且判断后到达的为真。

（4） 那为了实现ARP欺骗，需要使PC3成为后到达的回应包。

（5） 因此需要使PC3连续不断的发送这样的回应包，总会把哪个正确的回应包覆盖掉，然后加入ARP缓存里面去。然后ARP缓存对应就会出错，本来应该发送到PC2的数据就会被发送到PC3那里。

### ARP欺骗

![img](http://cdn.ayusummer233.top/img/edca71585baf9c5a6c3eadcc554e7fcb.png)

 方式有两种ARP欺骗，第一种是冒充主机，第二种是冒充网关，现在普遍都是双向欺骗的，就是欺骗PC1我是网关，欺骗网关我是PC1

   ***\**\*如何实现让PC1不能上网？\*\**\***

   首先以上图为例，我们假设PC1的IP地址为192.168.1.1，网关的IP地址为192.168.1.254，欺骗者的IP地址为192.168.1.2

（1） 若PC1想要上网，需要寻找网关MAC，于是PC1会发送广播ARP Request，欺骗者就会接收这个请求报文，并通过不断发送ARP应答给发送端，告诉PC1，我就是网关，192.168.1.254就是我，所以每次PC1要去往网关的时候数据都去了我这里。

（2） 我还会给网关发送一个ARP应答包，告诉网关，192.168.1.1的地址是指向我的，你只要将发送给这个地址的数据包都发给我就可以了！于是，网关就会更新自己的ARP缓存，将去PC1的数据包都发给我。

   那么PC1就无法到达网关，网关也无法到达PC1，欺骗者将中间的通信路线给截断了，PC1数据无法到达网关，于是无法正常上网通信。

## 命令执行漏洞利用学习和复现

